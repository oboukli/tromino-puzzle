
var createTrmnMod = (() => {
  var _scriptName = typeof document != 'undefined' ? document.currentScript?.src : undefined;
  
  return (
function(moduleArg = {}) {
  var moduleRtn;

// include: shell.js
// The Module object: Our interface to the outside world. We import
// and export values on it. There are various ways Module can be used:
// 1. Not defined. We create it here
// 2. A function parameter, function(moduleArg) => Promise<Module>
// 3. pre-run appended it, var Module = {}; ..generated code..
// 4. External script tag defines var Module.
// We need to check if Module already exists (e.g. case 3 above).
// Substitution will be replaced with actual code on later stage of the build,
// this way Closure Compiler will not mangle it (e.g. case 4. above).
// Note that if you want to run closure, and also to use Module
// after the generated code, you will need to define   var Module = {};
// before the code. Then that object will be used in the code, and you
// can continue to use Module afterwards as well.
var Module=moduleArg;// Set up the promise that indicates the Module is initialized
var readyPromiseResolve,readyPromiseReject;var readyPromise=new Promise((resolve,reject)=>{readyPromiseResolve=resolve;readyPromiseReject=reject});// Determine the runtime environment we are in. You can customize this by
// setting the ENVIRONMENT setting at compile time (see settings.js).
var ENVIRONMENT_IS_WEB=true;var ENVIRONMENT_IS_WORKER=false;// --pre-jses are emitted after the Module integration code, so that they can
// refer to Module (if they choose; they can also define Module)
// Sometimes an existing Module object exists with properties
// meant to overwrite the default module functionality. Here
// we collect those properties and reapply _after_ we configure
// the current environment's defaults to avoid having to be so
// defensive during initialization.
var moduleOverrides=Object.assign({},Module);var thisProgram="./this.program";var quit_=(status,toThrow)=>{throw toThrow};// `/` should be present at the end if `scriptDirectory` is not empty
var scriptDirectory="";function locateFile(path){return scriptDirectory+path}// Hooks that are implemented differently in different runtime environments.
var readAsync,readBinary;// Note that this includes Node.js workers when relevant (pthreads is enabled).
// Node.js workers are detected as a combination of ENVIRONMENT_IS_WORKER and
// ENVIRONMENT_IS_NODE.
if(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER){if(ENVIRONMENT_IS_WORKER){// Check worker, not web, since window could be polyfilled
scriptDirectory=self.location.href}else if(typeof document!="undefined"&&document.currentScript){// web
scriptDirectory=document.currentScript.src}// When MODULARIZE, this JS may be executed later, after document.currentScript
// is gone, so we saved it, and we use it here instead of any other info.
if(_scriptName){scriptDirectory=_scriptName}// blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.
// otherwise, slice off the final part of the url to find the script directory.
// if scriptDirectory does not contain a slash, lastIndexOf will return -1,
// and scriptDirectory will correctly be replaced with an empty string.
// If scriptDirectory contains a query (starting with ?) or a fragment (starting with #),
// they are removed because they could contain a slash.
if(scriptDirectory.startsWith("blob:")){scriptDirectory=""}else{scriptDirectory=scriptDirectory.substr(0,scriptDirectory.replace(/[?#].*/,"").lastIndexOf("/")+1)}{// include: web_or_worker_shell_read.js
readAsync=url=>fetch(url,{credentials:"same-origin"}).then(response=>{if(response.ok){return response.arrayBuffer()}return Promise.reject(new Error(response.status+" : "+response.url))})}}else// end include: web_or_worker_shell_read.js
{}var out=console.log.bind(console);var err=console.error.bind(console);// Merge back in the overrides
Object.assign(Module,moduleOverrides);// Free the object hierarchy contained in the overrides, this lets the GC
// reclaim data used.
moduleOverrides=null;// Emit code to handle expected values on the Module object. This applies Module.x
// to the proper local x. This has two benefits: first, we only emit it if it is
// expected to arrive, and second, by using a local everywhere else that can be
// minified.
// perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message
// end include: shell.js
// include: preamble.js
// === Preamble library stuff ===
// Documentation for the public APIs defined in this file must be updated in:
//    site/source/docs/api_reference/preamble.js.rst
// A prebuilt local version of the documentation is available at:
//    site/build/text/docs/api_reference/preamble.js.txt
// You can also build docs locally as HTML or other formats in site/
// An online HTML version (which may be of a different version of Emscripten)
//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html
var wasmBinary;// Wasm globals
var wasmMemory;//========================================
// Runtime essentials
//========================================
// whether we are quitting the application. no code should run after this.
// set in exit() and abort()
var ABORT=false;// set by exit() and abort().  Passed to 'onExit' handler.
// NOTE: This is also used as the process return code code in shell environments
// but only when noExitRuntime is false.
var EXITSTATUS;// Memory management
var/** @type {!Int8Array} */HEAP8,/** @type {!Uint8Array} */HEAPU8,/** @type {!Int16Array} */HEAP16,/** @type {!Uint16Array} */HEAPU16,/** @type {!Int32Array} */HEAP32,/** @type {!Uint32Array} */HEAPU32,/** @type {!Float32Array} */HEAPF32,/** @type {!Float64Array} */HEAPF64;// include: runtime_shared.js
function updateMemoryViews(){var b=wasmMemory.buffer;HEAP8=new Int8Array(b);HEAP16=new Int16Array(b);HEAPU8=new Uint8Array(b);HEAPU16=new Uint16Array(b);HEAP32=new Int32Array(b);HEAPU32=new Uint32Array(b);HEAPF32=new Float32Array(b);HEAPF64=new Float64Array(b)}// end include: runtime_shared.js
// include: runtime_stack_check.js
// end include: runtime_stack_check.js
var __ATPRERUN__=[];// functions called before the runtime is initialized
var __ATINIT__=[];// functions called during shutdown
var __ATPOSTRUN__=[];// functions called after the main() is called
var runtimeInitialized=false;function preRun(){callRuntimeCallbacks(__ATPRERUN__)}function initRuntime(){runtimeInitialized=true;callRuntimeCallbacks(__ATINIT__)}function postRun(){callRuntimeCallbacks(__ATPOSTRUN__)}function addOnInit(cb){__ATINIT__.unshift(cb)}// include: runtime_math.js
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/fround
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc
// end include: runtime_math.js
// A counter of dependencies for calling run(). If we need to
// do asynchronous work before running, increment this and
// decrement it. Incrementing must happen in a place like
// Module.preRun (used by emcc to add file preloading).
// Note that you can add dependencies in preRun, even though
// it happens right before run - run will be postponed until
// the dependencies are met.
var runDependencies=0;var runDependencyWatcher=null;var dependenciesFulfilled=null;function addRunDependency(id){runDependencies++}function removeRunDependency(id){runDependencies--;if(runDependencies==0){if(runDependencyWatcher!==null){clearInterval(runDependencyWatcher);runDependencyWatcher=null}if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback()}}}/** @param {string|number=} what */function abort(what){what="Aborted("+what+")";// TODO(sbc): Should we remove printing and leave it up to whoever
// catches the exception?
err(what);ABORT=true;what+=". Build with -sASSERTIONS for more info.";// Use a wasm runtime error, because a JS error might be seen as a foreign
// exception, which means we'd run destructors on it. We need the error to
// simply make the program stop.
// FIXME This approach does not work in Wasm EH because it currently does not assume
// all RuntimeErrors are from traps; it decides whether a RuntimeError is from
// a trap or not based on a hidden field within the object. So at the moment
// we don't have a way of throwing a wasm trap from JS. TODO Make a JS API that
// allows this in the wasm spec.
// Suppress closure compiler warning here. Closure compiler's builtin extern
// definition for WebAssembly.RuntimeError claims it takes no arguments even
// though it can.
// TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure gets fixed.
/** @suppress {checkTypes} */var e=new WebAssembly.RuntimeError(what);readyPromiseReject(e);// Throw the error whether or not MODULARIZE is set because abort is used
// in code paths apart from instantiation where an exception is expected
// to be thrown when abort is called.
throw e}// include: memoryprofiler.js
// end include: memoryprofiler.js
// include: URIUtils.js
// Prefix of data URIs emitted by SINGLE_FILE and related options.
var dataURIPrefix="data:application/octet-stream;base64,";/**
 * Indicates whether filename is a base64 data URI.
 * @noinline
 */var isDataURI=filename=>filename.startsWith(dataURIPrefix);// end include: URIUtils.js
// include: runtime_exceptions.js
// end include: runtime_exceptions.js
function findWasmBinary(){var f="trmn-wasm.wasm";if(!isDataURI(f)){return locateFile(f)}return f}var wasmBinaryFile;function getBinarySync(file){if(file==wasmBinaryFile&&wasmBinary){return new Uint8Array(wasmBinary)}if(readBinary){return readBinary(file)}throw"both async and sync fetching of the wasm failed"}function getBinaryPromise(binaryFile){// If we don't have the binary yet, load it asynchronously using readAsync.
if(!wasmBinary){// Fetch the binary using readAsync
return readAsync(binaryFile).then(response=>new Uint8Array(/** @type{!ArrayBuffer} */(response)),// Fall back to getBinarySync if readAsync fails
()=>getBinarySync(binaryFile))}// Otherwise, getBinarySync should be able to get it synchronously
return Promise.resolve().then(()=>getBinarySync(binaryFile))}function instantiateArrayBuffer(binaryFile,imports,receiver){return getBinaryPromise(binaryFile).then(binary=>WebAssembly.instantiate(binary,imports)).then(receiver,reason=>{err(`failed to asynchronously prepare wasm: ${reason}`);abort(reason)})}function instantiateAsync(binary,binaryFile,imports,callback){if(!binary&&typeof WebAssembly.instantiateStreaming=="function"&&!isDataURI(binaryFile)&&typeof fetch=="function"){return fetch(binaryFile,{credentials:"same-origin"}).then(response=>{// Suppress closure warning here since the upstream definition for
// instantiateStreaming only allows Promise<Repsponse> rather than
// an actual Response.
// TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure is fixed.
/** @suppress {checkTypes} */var result=WebAssembly.instantiateStreaming(response,imports);return result.then(callback,function(reason){// We expect the most common failure cause to be a bad MIME type for the binary,
// in which case falling back to ArrayBuffer instantiation should work.
err(`wasm streaming compile failed: ${reason}`);err("falling back to ArrayBuffer instantiation");return instantiateArrayBuffer(binaryFile,imports,callback)})})}return instantiateArrayBuffer(binaryFile,imports,callback)}function getWasmImports(){// prepare imports
return{"a":wasmImports}}// Create the wasm instance.
// Receives the wasm imports, returns the exports.
function createWasm(){var info=getWasmImports();// Load the wasm module and create an instance of using native support in the JS engine.
// handle a generated wasm instance, receiving its exports and
// performing other necessary setup
/** @param {WebAssembly.Module=} module*/function receiveInstance(instance,module){wasmExports=instance.exports;wasmExports=Asyncify.instrumentWasmExports(wasmExports);wasmMemory=wasmExports["Cd"];updateMemoryViews();wasmTable=wasmExports["Hd"];addOnInit(wasmExports["Dd"]);removeRunDependency("wasm-instantiate");return wasmExports}// wait for the pthread pool (if any)
addRunDependency("wasm-instantiate");// Prefer streaming instantiation if available.
function receiveInstantiationResult(result){// 'result' is a ResultObject object which has both the module and instance.
// receiveInstance() will swap in the exports (to Module.asm) so they can be called
// TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.
// When the regression is fixed, can restore the above PTHREADS-enabled path.
receiveInstance(result["instance"])}wasmBinaryFile??=findWasmBinary();// If instantiation fails, reject the module ready promise.
instantiateAsync(wasmBinary,wasmBinaryFile,info,receiveInstantiationResult).catch(readyPromiseReject);return{}}// include: runtime_debug.js
// end include: runtime_debug.js
// === Body ===
var ASM_CONSTS={61004:$0=>{var str=UTF8ToString($0)+"\n\n"+"Abort/Retry/Ignore/AlwaysIgnore? [ariA] :";var reply=window.prompt(str,"i");if(reply===null){reply="i"}return allocate(intArrayFromString(reply),"i8",ALLOC_NORMAL)},61229:()=>{if(typeof(AudioContext)!=="undefined"){return true}else if(typeof(webkitAudioContext)!=="undefined"){return true}return false},61376:()=>{if((typeof(navigator.mediaDevices)!=="undefined")&&(typeof(navigator.mediaDevices.getUserMedia)!=="undefined")){return true}else if(typeof(navigator.webkitGetUserMedia)!=="undefined"){return true}return false},61610:$0=>{if(typeof(Module["SDL2"])==="undefined"){Module["SDL2"]={}}var SDL2=Module["SDL2"];if(!$0){SDL2.audio={}}else{SDL2.capture={}}if(!SDL2.audioContext){if(typeof(AudioContext)!=="undefined"){SDL2.audioContext=new AudioContext}else if(typeof(webkitAudioContext)!=="undefined"){SDL2.audioContext=new webkitAudioContext}if(SDL2.audioContext){autoResumeAudioContext(SDL2.audioContext)}}return SDL2.audioContext===undefined?-1:0},62103:()=>{var SDL2=Module["SDL2"];return SDL2.audioContext.sampleRate},62171:($0,$1,$2,$3)=>{var SDL2=Module["SDL2"];var have_microphone=function(stream){if(SDL2.capture.silenceTimer!==undefined){clearTimeout(SDL2.capture.silenceTimer);SDL2.capture.silenceTimer=undefined}SDL2.capture.mediaStreamNode=SDL2.audioContext.createMediaStreamSource(stream);SDL2.capture.scriptProcessorNode=SDL2.audioContext.createScriptProcessor($1,$0,1);SDL2.capture.scriptProcessorNode.onaudioprocess=function(audioProcessingEvent){if((SDL2===undefined)||(SDL2.capture===undefined)){return}audioProcessingEvent.outputBuffer.getChannelData(0).fill(0);SDL2.capture.currentCaptureBuffer=audioProcessingEvent.inputBuffer;dynCall("vi",$2,[$3])};SDL2.capture.mediaStreamNode.connect(SDL2.capture.scriptProcessorNode);SDL2.capture.scriptProcessorNode.connect(SDL2.audioContext.destination);SDL2.capture.stream=stream};var no_microphone=function(error){};SDL2.capture.silenceBuffer=SDL2.audioContext.createBuffer($0,$1,SDL2.audioContext.sampleRate);SDL2.capture.silenceBuffer.getChannelData(0).fill(0);var silence_callback=function(){SDL2.capture.currentCaptureBuffer=SDL2.capture.silenceBuffer;dynCall("vi",$2,[$3])};SDL2.capture.silenceTimer=setTimeout(silence_callback,($1/SDL2.audioContext.sampleRate)*1e3);if((navigator.mediaDevices!==undefined)&&(navigator.mediaDevices.getUserMedia!==undefined)){navigator.mediaDevices.getUserMedia({audio:true,video:false}).then(have_microphone).catch(no_microphone)}else if(navigator.webkitGetUserMedia!==undefined){navigator.webkitGetUserMedia({audio:true,video:false},have_microphone,no_microphone)}},63823:($0,$1,$2,$3)=>{var SDL2=Module["SDL2"];SDL2.audio.scriptProcessorNode=SDL2.audioContext["createScriptProcessor"]($1,0,$0);SDL2.audio.scriptProcessorNode["onaudioprocess"]=function(e){if((SDL2===undefined)||(SDL2.audio===undefined)){return}SDL2.audio.currentOutputBuffer=e["outputBuffer"];dynCall("vi",$2,[$3])};SDL2.audio.scriptProcessorNode["connect"](SDL2.audioContext["destination"])},64233:($0,$1)=>{var SDL2=Module["SDL2"];var numChannels=SDL2.capture.currentCaptureBuffer.numberOfChannels;for(var c=0;c<numChannels;++c){var channelData=SDL2.capture.currentCaptureBuffer.getChannelData(c);if(channelData.length!=$1){throw"Web Audio capture buffer length mismatch! Destination size: "+channelData.length+" samples vs expected "+$1+" samples!"}if(numChannels==1){for(var j=0;j<$1;++j){setValue($0+(j*4),channelData[j],"float")}}else{for(var j=0;j<$1;++j){setValue($0+(((j*numChannels)+c)*4),channelData[j],"float")}}}},64838:($0,$1)=>{var SDL2=Module["SDL2"];var numChannels=SDL2.audio.currentOutputBuffer["numberOfChannels"];for(var c=0;c<numChannels;++c){var channelData=SDL2.audio.currentOutputBuffer["getChannelData"](c);if(channelData.length!=$1){throw"Web Audio output buffer length mismatch! Destination size: "+channelData.length+" samples vs expected "+$1+" samples!"}for(var j=0;j<$1;++j){channelData[j]=HEAPF32[$0+((j*numChannels+c)<<2)>>2]}}},65318:$0=>{var SDL2=Module["SDL2"];if($0){if(SDL2.capture.silenceTimer!==undefined){clearTimeout(SDL2.capture.silenceTimer)}if(SDL2.capture.stream!==undefined){var tracks=SDL2.capture.stream.getAudioTracks();for(var i=0;i<tracks.length;i++){SDL2.capture.stream.removeTrack(tracks[i])}SDL2.capture.stream=undefined}if(SDL2.capture.scriptProcessorNode!==undefined){SDL2.capture.scriptProcessorNode.onaudioprocess=function(audioProcessingEvent){};SDL2.capture.scriptProcessorNode.disconnect();SDL2.capture.scriptProcessorNode=undefined}if(SDL2.capture.mediaStreamNode!==undefined){SDL2.capture.mediaStreamNode.disconnect();SDL2.capture.mediaStreamNode=undefined}if(SDL2.capture.silenceBuffer!==undefined){SDL2.capture.silenceBuffer=undefined}SDL2.capture=undefined}else{if(SDL2.audio.scriptProcessorNode!=undefined){SDL2.audio.scriptProcessorNode.disconnect();SDL2.audio.scriptProcessorNode=undefined}SDL2.audio=undefined}if((SDL2.audioContext!==undefined)&&(SDL2.audio===undefined)&&(SDL2.capture===undefined)){SDL2.audioContext.close();SDL2.audioContext=undefined}},66490:()=>window.innerWidth,66520:()=>window.innerHeight,66551:($0,$1,$2)=>{var w=$0;var h=$1;var pixels=$2;if(!Module["SDL2"])Module["SDL2"]={};var SDL2=Module["SDL2"];if(SDL2.ctxCanvas!==Module["canvas"]){SDL2.ctx=Module["createContext"](Module["canvas"],false,true);SDL2.ctxCanvas=Module["canvas"]}if(SDL2.w!==w||SDL2.h!==h||SDL2.imageCtx!==SDL2.ctx){SDL2.image=SDL2.ctx.createImageData(w,h);SDL2.w=w;SDL2.h=h;SDL2.imageCtx=SDL2.ctx}var data=SDL2.image.data;var src=pixels>>2;var dst=0;var num;if(typeof CanvasPixelArray!=="undefined"&&data instanceof CanvasPixelArray){num=data.length;while(dst<num){var val=HEAP32[src];data[dst]=val&255;data[dst+1]=(val>>8)&255;data[dst+2]=(val>>16)&255;data[dst+3]=255;src++;dst+=4}}else{if(SDL2.data32Data!==data){SDL2.data32=new Int32Array(data.buffer);SDL2.data8=new Uint8Array(data.buffer);SDL2.data32Data=data}var data32=SDL2.data32;num=data32.length;data32.set(HEAP32.subarray(src,src+num));var data8=SDL2.data8;var i=3;var j=i+4*num;if(num%8==0){while(i<j){data8[i]=255;i=i+4|0;data8[i]=255;i=i+4|0;data8[i]=255;i=i+4|0;data8[i]=255;i=i+4|0;data8[i]=255;i=i+4|0;data8[i]=255;i=i+4|0;data8[i]=255;i=i+4|0;data8[i]=255;i=i+4|0}}else{while(i<j){data8[i]=255;i=i+4|0}}}SDL2.ctx.putImageData(SDL2.image,0,0)},68020:($0,$1,$2,$3,$4)=>{var w=$0;var h=$1;var hot_x=$2;var hot_y=$3;var pixels=$4;var canvas=document.createElement("canvas");canvas.width=w;canvas.height=h;var ctx=canvas.getContext("2d");var image=ctx.createImageData(w,h);var data=image.data;var src=pixels>>2;var dst=0;var num;if(typeof CanvasPixelArray!=="undefined"&&data instanceof CanvasPixelArray){num=data.length;while(dst<num){var val=HEAP32[src];data[dst]=val&255;data[dst+1]=(val>>8)&255;data[dst+2]=(val>>16)&255;data[dst+3]=(val>>24)&255;src++;dst+=4}}else{var data32=new Int32Array(data.buffer);num=data32.length;data32.set(HEAP32.subarray(src,src+num))}ctx.putImageData(image,0,0);var url=hot_x===0&&hot_y===0?"url("+canvas.toDataURL()+"), auto":"url("+canvas.toDataURL()+") "+hot_x+" "+hot_y+", auto";var urlBuf=_malloc(url.length+1);stringToUTF8(url,urlBuf,url.length+1);return urlBuf},69009:$0=>{if(Module["canvas"]){Module["canvas"].style["cursor"]=UTF8ToString($0)}},69092:()=>{if(Module["canvas"]){Module["canvas"].style["cursor"]="none"}}};// end include: preamble.js
/** @constructor */function ExitStatus(status){this.name="ExitStatus";this.message=`Program terminated with exit(${status})`;this.status=status}var callRuntimeCallbacks=callbacks=>{while(callbacks.length>0){// Pass the module as the first argument.
callbacks.shift()(Module)}};var noExitRuntime=true;/**
     * @param {number} ptr
     * @param {number} value
     * @param {string} type
     */function setValue(ptr,value,type="i8"){if(type.endsWith("*"))type="*";switch(type){case"i1":HEAP8[ptr]=value;break;case"i8":HEAP8[ptr]=value;break;case"i16":HEAP16[((ptr)>>1)]=value;break;case"i32":HEAP32[((ptr)>>2)]=value;break;case"i64":abort("to do setValue(i64) use WASM_BIGINT");case"float":HEAPF32[((ptr)>>2)]=value;break;case"double":HEAPF64[((ptr)>>3)]=value;break;case"*":HEAPU32[((ptr)>>2)]=value;break;default:abort(`invalid type for setValue: ${type}`)}}var stackRestore=val=>__emscripten_stack_restore(val);var stackSave=()=>_emscripten_stack_get_current();var ___call_sighandler=(fp,sig)=>(a1=>dynCall_vi(fp,a1))(sig);var UTF8Decoder=typeof TextDecoder!="undefined"?new TextDecoder:undefined;/**
     * Given a pointer 'idx' to a null-terminated UTF8-encoded string in the given
     * array that contains uint8 values, returns a copy of that string as a
     * Javascript String object.
     * heapOrArray is either a regular array, or a JavaScript typed array view.
     * @param {number} idx
     * @param {number=} maxBytesToRead
     * @return {string}
     */var UTF8ArrayToString=(heapOrArray,idx,maxBytesToRead)=>{var endIdx=idx+maxBytesToRead;var endPtr=idx;// TextDecoder needs to know the byte length in advance, it doesn't stop on
// null terminator by itself.  Also, use the length info to avoid running tiny
// strings through TextDecoder, since .subarray() allocates garbage.
// (As a tiny code save trick, compare endPtr against endIdx using a negation,
// so that undefined means Infinity)
while(heapOrArray[endPtr]&&!(endPtr>=endIdx))++endPtr;if(endPtr-idx>16&&heapOrArray.buffer&&UTF8Decoder){return UTF8Decoder.decode(heapOrArray.subarray(idx,endPtr))}var str="";// If building with TextDecoder, we have already computed the string length
// above, so test loop end condition against that
while(idx<endPtr){// For UTF8 byte structure, see:
// http://en.wikipedia.org/wiki/UTF-8#Description
// https://www.ietf.org/rfc/rfc2279.txt
// https://tools.ietf.org/html/rfc3629
var u0=heapOrArray[idx++];if(!(u0&128)){str+=String.fromCharCode(u0);continue}var u1=heapOrArray[idx++]&63;if((u0&224)==192){str+=String.fromCharCode(((u0&31)<<6)|u1);continue}var u2=heapOrArray[idx++]&63;if((u0&240)==224){u0=((u0&15)<<12)|(u1<<6)|u2}else{u0=((u0&7)<<18)|(u1<<12)|(u2<<6)|(heapOrArray[idx++]&63)}if(u0<65536){str+=String.fromCharCode(u0)}else{var ch=u0-65536;str+=String.fromCharCode(55296|(ch>>10),56320|(ch&1023))}}return str};/**
     * Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the
     * emscripten HEAP, returns a copy of that string as a Javascript String object.
     *
     * @param {number} ptr
     * @param {number=} maxBytesToRead - An optional length that specifies the
     *   maximum number of bytes to read. You can omit this parameter to scan the
     *   string until the first 0 byte. If maxBytesToRead is passed, and the string
     *   at [ptr, ptr+maxBytesToReadr[ contains a null byte in the middle, then the
     *   string will cut short at that byte index (i.e. maxBytesToRead will not
     *   produce a string of exact length [ptr, ptr+maxBytesToRead[) N.B. mixing
     *   frequent uses of UTF8ToString() with and without maxBytesToRead may throw
     *   JS JIT optimizations off, so it is worth to consider consistently using one
     * @return {string}
     */var UTF8ToString=(ptr,maxBytesToRead)=>ptr?UTF8ArrayToString(HEAPU8,ptr,maxBytesToRead):"";var SYSCALLS={varargs:undefined,getStr(ptr){var ret=UTF8ToString(ptr);return ret}};function ___syscall_fcntl64(fd,cmd,varargs){SYSCALLS.varargs=varargs;return 0}function ___syscall_ioctl(fd,op,varargs){SYSCALLS.varargs=varargs;return 0}function ___syscall_openat(dirfd,path,flags,varargs){SYSCALLS.varargs=varargs}var __abort_js=()=>{abort("")};var nowIsMonotonic=1;var __emscripten_get_now_is_monotonic=()=>nowIsMonotonic;var __emscripten_memcpy_js=(dest,src,num)=>HEAPU8.copyWithin(dest,src,src+num);var __emscripten_runtime_keepalive_clear=()=>{noExitRuntime=false;runtimeKeepaliveCounter=0};var timers={};var handleException=e=>{// Certain exception types we do not treat as errors since they are used for
// internal control flow.
// 1. ExitStatus, which is thrown by exit()
// 2. "unwind", which is thrown by emscripten_unwind_to_js_event_loop() and others
//    that wish to return to JS event loop.
if(e instanceof ExitStatus||e=="unwind"){return EXITSTATUS}quit_(1,e)};var runtimeKeepaliveCounter=0;var keepRuntimeAlive=()=>noExitRuntime||runtimeKeepaliveCounter>0;var _proc_exit=code=>{EXITSTATUS=code;if(!keepRuntimeAlive()){ABORT=true}quit_(code,new ExitStatus(code))};/** @suppress {duplicate } */ /** @param {boolean|number=} implicit */var exitJS=(status,implicit)=>{EXITSTATUS=status;_proc_exit(status)};var _exit=exitJS;var maybeExit=()=>{if(!keepRuntimeAlive()){try{_exit(EXITSTATUS)}catch(e){handleException(e)}}};var callUserCallback=func=>{if(ABORT){return}try{func();maybeExit()}catch(e){handleException(e)}};var _emscripten_get_now=()=>performance.now();var __setitimer_js=(which,timeout_ms)=>{// First, clear any existing timer.
if(timers[which]){clearTimeout(timers[which].id);delete timers[which]}// A timeout of zero simply cancels the current timeout so we have nothing
// more to do.
if(!timeout_ms)return 0;var id=setTimeout(()=>{delete timers[which];callUserCallback(()=>__emscripten_timeout(which,_emscripten_get_now()))},timeout_ms);timers[which]={id,timeout_ms};return 0};/** @param {number=} timeout */var safeSetTimeout=(func,timeout)=>setTimeout(()=>{callUserCallback(func)},timeout);var warnOnce=text=>{warnOnce.shown||={};if(!warnOnce.shown[text]){warnOnce.shown[text]=1;err(text)}};var Browser={useWebGL:false,isFullscreen:false,pointerLock:false,moduleContextCreatedCallbacks:[],workers:[],init(){if(Browser.initted)return;Browser.initted=true;// Canvas event setup
function pointerLockChange(){Browser.pointerLock=document["pointerLockElement"]===Module["canvas"]||document["mozPointerLockElement"]===Module["canvas"]||document["webkitPointerLockElement"]===Module["canvas"]||document["msPointerLockElement"]===Module["canvas"]}var canvas=Module["canvas"];if(canvas){// forced aspect ratio can be enabled by defining 'forcedAspectRatio' on Module
// Module['forcedAspectRatio'] = 4 / 3;
canvas.requestPointerLock=canvas["requestPointerLock"]||canvas["mozRequestPointerLock"]||canvas["webkitRequestPointerLock"]||canvas["msRequestPointerLock"]||(()=>{});canvas.exitPointerLock=document["exitPointerLock"]||document["mozExitPointerLock"]||document["webkitExitPointerLock"]||document["msExitPointerLock"]||(()=>{});// no-op if function does not exist
canvas.exitPointerLock=canvas.exitPointerLock.bind(document);document.addEventListener("pointerlockchange",pointerLockChange,false);document.addEventListener("mozpointerlockchange",pointerLockChange,false);document.addEventListener("webkitpointerlockchange",pointerLockChange,false);document.addEventListener("mspointerlockchange",pointerLockChange,false);if(Module["elementPointerLock"]){canvas.addEventListener("click",ev=>{if(!Browser.pointerLock&&Module["canvas"].requestPointerLock){Module["canvas"].requestPointerLock();ev.preventDefault()}},false)}}},createContext(/** @type {HTMLCanvasElement} */canvas,useWebGL,setInModule,webGLContextAttributes){if(useWebGL&&Module.ctx&&canvas==Module.canvas)return Module.ctx;// no need to recreate GL context if it's already been created for this canvas.
var ctx;var contextHandle;if(useWebGL){// For GLES2/desktop GL compatibility, adjust a few defaults to be different to WebGL defaults, so that they align better with the desktop defaults.
var contextAttributes={antialias:false,alpha:false,majorVersion:1};if(webGLContextAttributes){for(var attribute in webGLContextAttributes){contextAttributes[attribute]=webGLContextAttributes[attribute]}}// This check of existence of GL is here to satisfy Closure compiler, which yells if variable GL is referenced below but GL object is not
// actually compiled in because application is not doing any GL operations. TODO: Ideally if GL is not being used, this function
// Browser.createContext() should not even be emitted.
if(typeof GL!="undefined"){contextHandle=GL.createContext(canvas,contextAttributes);if(contextHandle){ctx=GL.getContext(contextHandle).GLctx}}}else{ctx=canvas.getContext("2d")}if(!ctx)return null;if(setInModule){Module.ctx=ctx;if(useWebGL)GL.makeContextCurrent(contextHandle);Browser.useWebGL=useWebGL;Browser.moduleContextCreatedCallbacks.forEach(callback=>callback());Browser.init()}return ctx},fullscreenHandlersInstalled:false,lockPointer:undefined,resizeCanvas:undefined,requestFullscreen(lockPointer,resizeCanvas){Browser.lockPointer=lockPointer;Browser.resizeCanvas=resizeCanvas;if(typeof Browser.lockPointer=="undefined")Browser.lockPointer=true;if(typeof Browser.resizeCanvas=="undefined")Browser.resizeCanvas=false;var canvas=Module["canvas"];function fullscreenChange(){Browser.isFullscreen=false;var canvasContainer=canvas.parentNode;if((document["fullscreenElement"]||document["mozFullScreenElement"]||document["msFullscreenElement"]||document["webkitFullscreenElement"]||document["webkitCurrentFullScreenElement"])===canvasContainer){canvas.exitFullscreen=Browser.exitFullscreen;if(Browser.lockPointer)canvas.requestPointerLock();Browser.isFullscreen=true;if(Browser.resizeCanvas){Browser.setFullscreenCanvasSize()}else{Browser.updateCanvasDimensions(canvas)}}else{// remove the full screen specific parent of the canvas again to restore the HTML structure from before going full screen
canvasContainer.parentNode.insertBefore(canvas,canvasContainer);canvasContainer.parentNode.removeChild(canvasContainer);if(Browser.resizeCanvas){Browser.setWindowedCanvasSize()}else{Browser.updateCanvasDimensions(canvas)}}Module["onFullScreen"]?.(Browser.isFullscreen);Module["onFullscreen"]?.(Browser.isFullscreen)}if(!Browser.fullscreenHandlersInstalled){Browser.fullscreenHandlersInstalled=true;document.addEventListener("fullscreenchange",fullscreenChange,false);document.addEventListener("mozfullscreenchange",fullscreenChange,false);document.addEventListener("webkitfullscreenchange",fullscreenChange,false);document.addEventListener("MSFullscreenChange",fullscreenChange,false)}// create a new parent to ensure the canvas has no siblings. this allows browsers to optimize full screen performance when its parent is the full screen root
var canvasContainer=document.createElement("div");canvas.parentNode.insertBefore(canvasContainer,canvas);canvasContainer.appendChild(canvas);// use parent of canvas as full screen root to allow aspect ratio correction (Firefox stretches the root to screen size)
canvasContainer.requestFullscreen=canvasContainer["requestFullscreen"]||canvasContainer["mozRequestFullScreen"]||canvasContainer["msRequestFullscreen"]||(canvasContainer["webkitRequestFullscreen"]?()=>canvasContainer["webkitRequestFullscreen"](Element["ALLOW_KEYBOARD_INPUT"]):null)||(canvasContainer["webkitRequestFullScreen"]?()=>canvasContainer["webkitRequestFullScreen"](Element["ALLOW_KEYBOARD_INPUT"]):null);canvasContainer.requestFullscreen()},exitFullscreen(){// This is workaround for chrome. Trying to exit from fullscreen
// not in fullscreen state will cause "TypeError: Document not active"
// in chrome. See https://github.com/emscripten-core/emscripten/pull/8236
if(!Browser.isFullscreen){return false}var CFS=document["exitFullscreen"]||document["cancelFullScreen"]||document["mozCancelFullScreen"]||document["msExitFullscreen"]||document["webkitCancelFullScreen"]||(()=>{});CFS.apply(document,[]);return true},safeSetTimeout(func,timeout){// Legacy function, this is used by the SDL2 port so we need to keep it
// around at least until that is updated.
// See https://github.com/libsdl-org/SDL/pull/6304
return safeSetTimeout(func,timeout)},getMimetype(name){return{"jpg":"image/jpeg","jpeg":"image/jpeg","png":"image/png","bmp":"image/bmp","ogg":"audio/ogg","wav":"audio/wav","mp3":"audio/mpeg"}[name.substr(name.lastIndexOf(".")+1)]},getUserMedia(func){window.getUserMedia||=navigator["getUserMedia"]||navigator["mozGetUserMedia"];window.getUserMedia(func)},getMovementX(event){return event["movementX"]||event["mozMovementX"]||event["webkitMovementX"]||0},getMovementY(event){return event["movementY"]||event["mozMovementY"]||event["webkitMovementY"]||0},getMouseWheelDelta(event){var delta=0;switch(event.type){case"DOMMouseScroll":// 3 lines make up a step
delta=event.detail/3;break;case"mousewheel":// 120 units make up a step
delta=event.wheelDelta/120;break;case"wheel":delta=event.deltaY;switch(event.deltaMode){case 0:// DOM_DELTA_PIXEL: 100 pixels make up a step
delta/=100;break;case 1:// DOM_DELTA_LINE: 3 lines make up a step
delta/=3;break;case 2:// DOM_DELTA_PAGE: A page makes up 80 steps
delta*=80;break;default:throw"unrecognized mouse wheel delta mode: "+event.deltaMode}break;default:throw"unrecognized mouse wheel event: "+event.type}return delta},mouseX:0,mouseY:0,mouseMovementX:0,mouseMovementY:0,touches:{},lastTouches:{},calculateMouseCoords(pageX,pageY){// Calculate the movement based on the changes
// in the coordinates.
var rect=Module["canvas"].getBoundingClientRect();var cw=Module["canvas"].width;var ch=Module["canvas"].height;// Neither .scrollX or .pageXOffset are defined in a spec, but
// we prefer .scrollX because it is currently in a spec draft.
// (see: http://www.w3.org/TR/2013/WD-cssom-view-20131217/)
var scrollX=((typeof window.scrollX!="undefined")?window.scrollX:window.pageXOffset);var scrollY=((typeof window.scrollY!="undefined")?window.scrollY:window.pageYOffset);var adjustedX=pageX-(scrollX+rect.left);var adjustedY=pageY-(scrollY+rect.top);// the canvas might be CSS-scaled compared to its backbuffer;
// SDL-using content will want mouse coordinates in terms
// of backbuffer units.
adjustedX=adjustedX*(cw/rect.width);adjustedY=adjustedY*(ch/rect.height);return{x:adjustedX,y:adjustedY}},setMouseCoords(pageX,pageY){const{x,y}=Browser.calculateMouseCoords(pageX,pageY);Browser.mouseMovementX=x-Browser.mouseX;Browser.mouseMovementY=y-Browser.mouseY;Browser.mouseX=x;Browser.mouseY=y},calculateMouseEvent(event){// event should be mousemove, mousedown or mouseup
if(Browser.pointerLock){// When the pointer is locked, calculate the coordinates
// based on the movement of the mouse.
// Workaround for Firefox bug 764498
if(event.type!="mousemove"&&("mozMovementX"in event)){Browser.mouseMovementX=Browser.mouseMovementY=0}else{Browser.mouseMovementX=Browser.getMovementX(event);Browser.mouseMovementY=Browser.getMovementY(event)}// add the mouse delta to the current absolute mouse position
Browser.mouseX+=Browser.mouseMovementX;Browser.mouseY+=Browser.mouseMovementY}else{if(event.type==="touchstart"||event.type==="touchend"||event.type==="touchmove"){var touch=event.touch;if(touch===undefined){return}// the "touch" property is only defined in SDL
var coords=Browser.calculateMouseCoords(touch.pageX,touch.pageY);if(event.type==="touchstart"){Browser.lastTouches[touch.identifier]=coords;Browser.touches[touch.identifier]=coords}else if(event.type==="touchend"||event.type==="touchmove"){var last=Browser.touches[touch.identifier];last||=coords;Browser.lastTouches[touch.identifier]=last;Browser.touches[touch.identifier]=coords}return}Browser.setMouseCoords(event.pageX,event.pageY)}},resizeListeners:[],updateResizeListeners(){var canvas=Module["canvas"];Browser.resizeListeners.forEach(listener=>listener(canvas.width,canvas.height))},setCanvasSize(width,height,noUpdates){var canvas=Module["canvas"];Browser.updateCanvasDimensions(canvas,width,height);if(!noUpdates)Browser.updateResizeListeners()},windowedWidth:0,windowedHeight:0,setFullscreenCanvasSize(){// check if SDL is available
if(typeof SDL!="undefined"){var flags=HEAPU32[((SDL.screen)>>2)];flags=flags|8388608;// set SDL_FULLSCREEN flag
HEAP32[((SDL.screen)>>2)]=flags}Browser.updateCanvasDimensions(Module["canvas"]);Browser.updateResizeListeners()},setWindowedCanvasSize(){// check if SDL is available
if(typeof SDL!="undefined"){var flags=HEAPU32[((SDL.screen)>>2)];flags=flags&~8388608;// clear SDL_FULLSCREEN flag
HEAP32[((SDL.screen)>>2)]=flags}Browser.updateCanvasDimensions(Module["canvas"]);Browser.updateResizeListeners()},updateCanvasDimensions(canvas,wNative,hNative){if(wNative&&hNative){canvas.widthNative=wNative;canvas.heightNative=hNative}else{wNative=canvas.widthNative;hNative=canvas.heightNative}var w=wNative;var h=hNative;if(Module["forcedAspectRatio"]&&Module["forcedAspectRatio"]>0){if(w/h<Module["forcedAspectRatio"]){w=Math.round(h*Module["forcedAspectRatio"])}else{h=Math.round(w/Module["forcedAspectRatio"])}}if(((document["fullscreenElement"]||document["mozFullScreenElement"]||document["msFullscreenElement"]||document["webkitFullscreenElement"]||document["webkitCurrentFullScreenElement"])===canvas.parentNode)&&(typeof screen!="undefined")){var factor=Math.min(screen.width/w,screen.height/h);w=Math.round(w*factor);h=Math.round(h*factor)}if(Browser.resizeCanvas){if(canvas.width!=w)canvas.width=w;if(canvas.height!=h)canvas.height=h;if(typeof canvas.style!="undefined"){canvas.style.removeProperty("width");canvas.style.removeProperty("height")}}else{if(canvas.width!=wNative)canvas.width=wNative;if(canvas.height!=hNative)canvas.height=hNative;if(typeof canvas.style!="undefined"){if(w!=wNative||h!=hNative){canvas.style.setProperty("width",w+"px","important");canvas.style.setProperty("height",h+"px","important")}else{canvas.style.removeProperty("width");canvas.style.removeProperty("height")}}}}};var EGL={errorCode:12288,defaultDisplayInitialized:false,currentContext:0,currentReadSurface:0,currentDrawSurface:0,contextAttributes:{alpha:false,depth:false,stencil:false,antialias:false},stringCache:{},setErrorCode(code){EGL.errorCode=code},chooseConfig(display,attribList,config,config_size,numConfigs){if(display!=62e3){EGL.setErrorCode(12296);/* EGL_BAD_DISPLAY */return 0}if(attribList){// read attribList if it is non-null
for(;;){var param=HEAP32[((attribList)>>2)];if(param==12321)/*EGL_ALPHA_SIZE*/{var alphaSize=HEAP32[(((attribList)+(4))>>2)];EGL.contextAttributes.alpha=(alphaSize>0)}else if(param==12325)/*EGL_DEPTH_SIZE*/{var depthSize=HEAP32[(((attribList)+(4))>>2)];EGL.contextAttributes.depth=(depthSize>0)}else if(param==12326)/*EGL_STENCIL_SIZE*/{var stencilSize=HEAP32[(((attribList)+(4))>>2)];EGL.contextAttributes.stencil=(stencilSize>0)}else if(param==12337)/*EGL_SAMPLES*/{var samples=HEAP32[(((attribList)+(4))>>2)];EGL.contextAttributes.antialias=(samples>0)}else if(param==12338)/*EGL_SAMPLE_BUFFERS*/{var samples=HEAP32[(((attribList)+(4))>>2)];EGL.contextAttributes.antialias=(samples==1)}else if(param==12544)/*EGL_CONTEXT_PRIORITY_LEVEL_IMG*/{var requestedPriority=HEAP32[(((attribList)+(4))>>2)];EGL.contextAttributes.lowLatency=(requestedPriority!=12547)}else if(param==12344)/*EGL_NONE*/{break}attribList+=8}}if((!config||!config_size)&&!numConfigs){EGL.setErrorCode(12300);/* EGL_BAD_PARAMETER */return 0}if(numConfigs){HEAP32[((numConfigs)>>2)]=1}// Total number of supported configs: 1.
if(config&&config_size>0){HEAPU32[((config)>>2)]=62002}EGL.setErrorCode(12288);/* EGL_SUCCESS */return 1}};var _eglBindAPI=api=>{if(api==12448)/* EGL_OPENGL_ES_API */{EGL.setErrorCode(12288);/* EGL_SUCCESS */return 1}// if (api == 0x30A1 /* EGL_OPENVG_API */ || api == 0x30A2 /* EGL_OPENGL_API */) {
EGL.setErrorCode(12300);/* EGL_BAD_PARAMETER */return 0};var _eglChooseConfig=(display,attrib_list,configs,config_size,numConfigs)=>EGL.chooseConfig(display,attrib_list,configs,config_size,numConfigs);var GLctx;var webgl_enable_ANGLE_instanced_arrays=ctx=>{// Extension available in WebGL 1 from Firefox 26 and Google Chrome 30 onwards. Core feature in WebGL 2.
var ext=ctx.getExtension("ANGLE_instanced_arrays");// Because this extension is a core function in WebGL 2, assign the extension entry points in place of
// where the core functions will reside in WebGL 2. This way the calling code can call these without
// having to dynamically branch depending if running against WebGL 1 or WebGL 2.
if(ext){ctx["vertexAttribDivisor"]=(index,divisor)=>ext["vertexAttribDivisorANGLE"](index,divisor);ctx["drawArraysInstanced"]=(mode,first,count,primcount)=>ext["drawArraysInstancedANGLE"](mode,first,count,primcount);ctx["drawElementsInstanced"]=(mode,count,type,indices,primcount)=>ext["drawElementsInstancedANGLE"](mode,count,type,indices,primcount);return 1}};var webgl_enable_OES_vertex_array_object=ctx=>{// Extension available in WebGL 1 from Firefox 25 and WebKit 536.28/desktop Safari 6.0.3 onwards. Core feature in WebGL 2.
var ext=ctx.getExtension("OES_vertex_array_object");if(ext){ctx["createVertexArray"]=()=>ext["createVertexArrayOES"]();ctx["deleteVertexArray"]=vao=>ext["deleteVertexArrayOES"](vao);ctx["bindVertexArray"]=vao=>ext["bindVertexArrayOES"](vao);ctx["isVertexArray"]=vao=>ext["isVertexArrayOES"](vao);return 1}};var webgl_enable_WEBGL_draw_buffers=ctx=>{// Extension available in WebGL 1 from Firefox 28 onwards. Core feature in WebGL 2.
var ext=ctx.getExtension("WEBGL_draw_buffers");if(ext){ctx["drawBuffers"]=(n,bufs)=>ext["drawBuffersWEBGL"](n,bufs);return 1}};var webgl_enable_EXT_polygon_offset_clamp=ctx=>!!(ctx.extPolygonOffsetClamp=ctx.getExtension("EXT_polygon_offset_clamp"));var webgl_enable_EXT_clip_control=ctx=>!!(ctx.extClipControl=ctx.getExtension("EXT_clip_control"));var webgl_enable_WEBGL_polygon_mode=ctx=>!!(ctx.webglPolygonMode=ctx.getExtension("WEBGL_polygon_mode"));var webgl_enable_WEBGL_multi_draw=ctx=>!!(ctx.multiDrawWebgl=ctx.getExtension("WEBGL_multi_draw"));var getEmscriptenSupportedExtensions=ctx=>{// Restrict the list of advertised extensions to those that we actually
// support.
var supportedExtensions=[// WebGL 1 extensions
"ANGLE_instanced_arrays","EXT_blend_minmax","EXT_disjoint_timer_query","EXT_frag_depth","EXT_shader_texture_lod","EXT_sRGB","OES_element_index_uint","OES_fbo_render_mipmap","OES_standard_derivatives","OES_texture_float","OES_texture_half_float","OES_texture_half_float_linear","OES_vertex_array_object","WEBGL_color_buffer_float","WEBGL_depth_texture","WEBGL_draw_buffers",// WebGL 1 and WebGL 2 extensions
"EXT_clip_control","EXT_color_buffer_half_float","EXT_depth_clamp","EXT_float_blend","EXT_polygon_offset_clamp","EXT_texture_compression_bptc","EXT_texture_compression_rgtc","EXT_texture_filter_anisotropic","KHR_parallel_shader_compile","OES_texture_float_linear","WEBGL_blend_func_extended","WEBGL_compressed_texture_astc","WEBGL_compressed_texture_etc","WEBGL_compressed_texture_etc1","WEBGL_compressed_texture_s3tc","WEBGL_compressed_texture_s3tc_srgb","WEBGL_debug_renderer_info","WEBGL_debug_shaders","WEBGL_lose_context","WEBGL_multi_draw","WEBGL_polygon_mode"];// .getSupportedExtensions() can return null if context is lost, so coerce to empty array.
return(ctx.getSupportedExtensions()||[]).filter(ext=>supportedExtensions.includes(ext))};var GL={counter:1,buffers:[],programs:[],framebuffers:[],renderbuffers:[],textures:[],shaders:[],vaos:[],contexts:[],offscreenCanvases:{},queries:[],stringCache:{},unpackAlignment:4,unpackRowLength:0,recordError:errorCode=>{if(!GL.lastError){GL.lastError=errorCode}},getNewId:table=>{var ret=GL.counter++;for(var i=table.length;i<ret;i++){table[i]=null}return ret},genObject:(n,buffers,createFunction,objectTable)=>{for(var i=0;i<n;i++){var buffer=GLctx[createFunction]();var id=buffer&&GL.getNewId(objectTable);if(buffer){buffer.name=id;objectTable[id]=buffer}else{GL.recordError(1282)}HEAP32[(((buffers)+(i*4))>>2)]=id}},getSource:(shader,count,string,length)=>{var source="";for(var i=0;i<count;++i){var len=length?HEAPU32[(((length)+(i*4))>>2)]:undefined;source+=UTF8ToString(HEAPU32[(((string)+(i*4))>>2)],len)}return source},createContext:(/** @type {HTMLCanvasElement} */canvas,webGLContextAttributes)=>{// BUG: Workaround Safari WebGL issue: After successfully acquiring WebGL
// context on a canvas, calling .getContext() will always return that
// context independent of which 'webgl' or 'webgl2'
// context version was passed. See:
//   https://bugs.webkit.org/show_bug.cgi?id=222758
// and:
//   https://github.com/emscripten-core/emscripten/issues/13295.
// TODO: Once the bug is fixed and shipped in Safari, adjust the Safari
// version field in above check.
if(!canvas.getContextSafariWebGL2Fixed){canvas.getContextSafariWebGL2Fixed=canvas.getContext;/** @type {function(this:HTMLCanvasElement, string, (Object|null)=): (Object|null)} */function fixedGetContext(ver,attrs){var gl=canvas.getContextSafariWebGL2Fixed(ver,attrs);return((ver=="webgl")==(gl instanceof WebGLRenderingContext))?gl:null}canvas.getContext=fixedGetContext}var ctx=(canvas.getContext("webgl",webGLContextAttributes));// https://caniuse.com/#feat=webgl
if(!ctx)return 0;var handle=GL.registerContext(ctx,webGLContextAttributes);return handle},registerContext:(ctx,webGLContextAttributes)=>{// without pthreads a context is just an integer ID
var handle=GL.getNewId(GL.contexts);var context={handle,attributes:webGLContextAttributes,version:webGLContextAttributes.majorVersion,GLctx:ctx};// Store the created context object so that we can access the context
// given a canvas without having to pass the parameters again.
if(ctx.canvas)ctx.canvas.GLctxObject=context;GL.contexts[handle]=context;if(typeof webGLContextAttributes.enableExtensionsByDefault=="undefined"||webGLContextAttributes.enableExtensionsByDefault){GL.initExtensions(context)}return handle},makeContextCurrent:contextHandle=>{// Active Emscripten GL layer context object.
GL.currentContext=GL.contexts[contextHandle];// Active WebGL context object.
Module.ctx=GLctx=GL.currentContext?.GLctx;return!(contextHandle&&!GLctx)},getContext:contextHandle=>GL.contexts[contextHandle],deleteContext:contextHandle=>{if(GL.currentContext===GL.contexts[contextHandle]){GL.currentContext=null}if(typeof JSEvents=="object"){// Release all JS event handlers on the DOM element that the GL context is
// associated with since the context is now deleted.
JSEvents.removeAllHandlersOnTarget(GL.contexts[contextHandle].GLctx.canvas)}// Make sure the canvas object no longer refers to the context object so
// there are no GC surprises.
if(GL.contexts[contextHandle]&&GL.contexts[contextHandle].GLctx.canvas){GL.contexts[contextHandle].GLctx.canvas.GLctxObject=undefined}GL.contexts[contextHandle]=null},initExtensions:context=>{// If this function is called without a specific context object, init the
// extensions of the currently active context.
context||=GL.currentContext;if(context.initExtensionsDone)return;context.initExtensionsDone=true;var GLctx=context.GLctx;// Detect the presence of a few extensions manually, ction GL interop
// layer itself will need to know if they exist.
// Extensions that are available in both WebGL 1 and WebGL 2
webgl_enable_WEBGL_multi_draw(GLctx);webgl_enable_EXT_polygon_offset_clamp(GLctx);webgl_enable_EXT_clip_control(GLctx);webgl_enable_WEBGL_polygon_mode(GLctx);// Extensions that are only available in WebGL 1 (the calls will be no-ops
// if called on a WebGL 2 context active)
webgl_enable_ANGLE_instanced_arrays(GLctx);webgl_enable_OES_vertex_array_object(GLctx);webgl_enable_WEBGL_draw_buffers(GLctx);{GLctx.disjointTimerQueryExt=GLctx.getExtension("EXT_disjoint_timer_query")}getEmscriptenSupportedExtensions(GLctx).forEach(ext=>{// WEBGL_lose_context, WEBGL_debug_renderer_info and WEBGL_debug_shaders
// are not enabled by default.
if(!ext.includes("lose_context")&&!ext.includes("debug")){// Call .getExtension() to enable that extension permanently.
GLctx.getExtension(ext)}})}};var _eglCreateContext=(display,config,hmm,contextAttribs)=>{if(display!=62e3){EGL.setErrorCode(12296);/* EGL_BAD_DISPLAY */return 0}// EGL 1.4 spec says default EGL_CONTEXT_CLIENT_VERSION is GLES1, but this is not supported by Emscripten.
// So user must pass EGL_CONTEXT_CLIENT_VERSION == 2 to initialize EGL.
var glesContextVersion=1;for(;;){var param=HEAP32[((contextAttribs)>>2)];if(param==12440)/*EGL_CONTEXT_CLIENT_VERSION*/{glesContextVersion=HEAP32[(((contextAttribs)+(4))>>2)]}else if(param==12344)/*EGL_NONE*/{break}else{/* EGL1.4 specifies only EGL_CONTEXT_CLIENT_VERSION as supported attribute */EGL.setErrorCode(12292);/*EGL_BAD_ATTRIBUTE*/return 0}contextAttribs+=8}if(glesContextVersion!=2){EGL.setErrorCode(12293);/* EGL_BAD_CONFIG */return 0}/* EGL_NO_CONTEXT */EGL.contextAttributes.majorVersion=glesContextVersion-1;// WebGL 1 is GLES 2, WebGL2 is GLES3
EGL.contextAttributes.minorVersion=0;EGL.context=GL.createContext(Module["canvas"],EGL.contextAttributes);if(EGL.context!=0){EGL.setErrorCode(12288);// Run callbacks so that GL emulation works
GL.makeContextCurrent(EGL.context);Browser.useWebGL=true;Browser.moduleContextCreatedCallbacks.forEach(callback=>callback());// Note: This function only creates a context, but it shall not make it active.
GL.makeContextCurrent(null);return 62004}else{EGL.setErrorCode(12297);// By the EGL 1.4 spec, an implementation that does not support GLES2 (WebGL in this case), this error code is set.
return 0}};/* EGL_NO_CONTEXT */var _eglCreateWindowSurface=(display,config,win,attrib_list)=>{if(display!=62e3){EGL.setErrorCode(12296);/* EGL_BAD_DISPLAY */return 0}if(config!=62002){EGL.setErrorCode(12293);/* EGL_BAD_CONFIG */return 0}// TODO: Examine attrib_list! Parameters that can be present there are:
// - EGL_RENDER_BUFFER (must be EGL_BACK_BUFFER)
// - EGL_VG_COLORSPACE (can't be set)
// - EGL_VG_ALPHA_FORMAT (can't be set)
EGL.setErrorCode(12288);/* EGL_SUCCESS */return 62006};/* Magic ID for Emscripten 'default surface' */var _eglDestroyContext=(display,context)=>{if(display!=62e3){EGL.setErrorCode(12296);/* EGL_BAD_DISPLAY */return 0}if(context!=62004){EGL.setErrorCode(12294);/* EGL_BAD_CONTEXT */return 0}GL.deleteContext(EGL.context);EGL.setErrorCode(12288);/* EGL_SUCCESS */if(EGL.currentContext==context){EGL.currentContext=0}return 1};/* EGL_TRUE */var _eglDestroySurface=(display,surface)=>{if(display!=62e3){EGL.setErrorCode(12296);/* EGL_BAD_DISPLAY */return 0}if(surface!=62006)/* Magic ID for the only EGLSurface supported by Emscripten */{EGL.setErrorCode(12301);/* EGL_BAD_SURFACE */return 1}if(EGL.currentReadSurface==surface){EGL.currentReadSurface=0}if(EGL.currentDrawSurface==surface){EGL.currentDrawSurface=0}EGL.setErrorCode(12288);/* EGL_SUCCESS */return 1};/* Magic ID for Emscripten 'default surface' */var _eglGetConfigAttrib=(display,config,attribute,value)=>{if(display!=62e3){EGL.setErrorCode(12296);/* EGL_BAD_DISPLAY */return 0}if(config!=62002){EGL.setErrorCode(12293);/* EGL_BAD_CONFIG */return 0}if(!value){EGL.setErrorCode(12300);/* EGL_BAD_PARAMETER */return 0}EGL.setErrorCode(12288);/* EGL_SUCCESS */switch(attribute){case 12320:// EGL_BUFFER_SIZE
HEAP32[((value)>>2)]=EGL.contextAttributes.alpha?32:24;return 1;case 12321:// EGL_ALPHA_SIZE
HEAP32[((value)>>2)]=EGL.contextAttributes.alpha?8:0;return 1;case 12322:// EGL_BLUE_SIZE
HEAP32[((value)>>2)]=8;return 1;case 12323:// EGL_GREEN_SIZE
HEAP32[((value)>>2)]=8;return 1;case 12324:// EGL_RED_SIZE
HEAP32[((value)>>2)]=8;return 1;case 12325:// EGL_DEPTH_SIZE
HEAP32[((value)>>2)]=EGL.contextAttributes.depth?24:0;return 1;case 12326:// EGL_STENCIL_SIZE
HEAP32[((value)>>2)]=EGL.contextAttributes.stencil?8:0;return 1;case 12327:// EGL_CONFIG_CAVEAT
// We can return here one of EGL_NONE (0x3038), EGL_SLOW_CONFIG (0x3050) or EGL_NON_CONFORMANT_CONFIG (0x3051).
HEAP32[((value)>>2)]=12344;return 1;case 12328:// EGL_CONFIG_ID
HEAP32[((value)>>2)]=62002;return 1;case 12329:// EGL_LEVEL
HEAP32[((value)>>2)]=0;return 1;case 12330:// EGL_MAX_PBUFFER_HEIGHT
HEAP32[((value)>>2)]=4096;return 1;case 12331:// EGL_MAX_PBUFFER_PIXELS
HEAP32[((value)>>2)]=16777216;return 1;case 12332:// EGL_MAX_PBUFFER_WIDTH
HEAP32[((value)>>2)]=4096;return 1;case 12333:// EGL_NATIVE_RENDERABLE
HEAP32[((value)>>2)]=0;return 1;case 12334:// EGL_NATIVE_VISUAL_ID
HEAP32[((value)>>2)]=0;return 1;case 12335:// EGL_NATIVE_VISUAL_TYPE
HEAP32[((value)>>2)]=12344;return 1;case 12337:// EGL_SAMPLES
HEAP32[((value)>>2)]=EGL.contextAttributes.antialias?4:0;return 1;case 12338:// EGL_SAMPLE_BUFFERS
HEAP32[((value)>>2)]=EGL.contextAttributes.antialias?1:0;return 1;case 12339:// EGL_SURFACE_TYPE
HEAP32[((value)>>2)]=4;return 1;case 12340:// EGL_TRANSPARENT_TYPE
// If this returns EGL_TRANSPARENT_RGB (0x3052), transparency is used through color-keying. No such thing applies to Emscripten canvas.
HEAP32[((value)>>2)]=12344;return 1;case 12341:// EGL_TRANSPARENT_BLUE_VALUE
case 12342:// EGL_TRANSPARENT_GREEN_VALUE
case 12343:// EGL_TRANSPARENT_RED_VALUE
// "If EGL_TRANSPARENT_TYPE is EGL_NONE, then the values for EGL_TRANSPARENT_RED_VALUE, EGL_TRANSPARENT_GREEN_VALUE, and EGL_TRANSPARENT_BLUE_VALUE are undefined."
HEAP32[((value)>>2)]=-1;return 1;case 12345:// EGL_BIND_TO_TEXTURE_RGB
case 12346:// EGL_BIND_TO_TEXTURE_RGBA
HEAP32[((value)>>2)]=0;return 1;case 12347:// EGL_MIN_SWAP_INTERVAL
HEAP32[((value)>>2)]=0;return 1;case 12348:// EGL_MAX_SWAP_INTERVAL
HEAP32[((value)>>2)]=1;return 1;case 12349:// EGL_LUMINANCE_SIZE
case 12350:// EGL_ALPHA_MASK_SIZE
HEAP32[((value)>>2)]=0;return 1;case 12351:// EGL_COLOR_BUFFER_TYPE
// EGL has two types of buffers: EGL_RGB_BUFFER and EGL_LUMINANCE_BUFFER.
HEAP32[((value)>>2)]=12430;return 1;case 12352:// EGL_RENDERABLE_TYPE
// A bit combination of EGL_OPENGL_ES_BIT,EGL_OPENVG_BIT,EGL_OPENGL_ES2_BIT and EGL_OPENGL_BIT.
HEAP32[((value)>>2)]=4;return 1;case 12354:// EGL_CONFORMANT
// "EGL_CONFORMANT is a mask indicating if a client API context created with respect to the corresponding EGLConfig will pass the required conformance tests for that API."
HEAP32[((value)>>2)]=0;return 1;default:EGL.setErrorCode(12292);/* EGL_BAD_ATTRIBUTE */return 0}};var _eglGetDisplay=nativeDisplayType=>{EGL.setErrorCode(12288);// Emscripten EGL implementation "emulates" X11, and eglGetDisplay is
// expected to accept/receive a pointer to an X11 Display object (or
// EGL_DEFAULT_DISPLAY).
if(nativeDisplayType!=0&&/* EGL_DEFAULT_DISPLAY */nativeDisplayType!=1)/* see library_xlib.js */{return 0}// EGL_NO_DISPLAY
return 62e3};var _eglGetError=()=>EGL.errorCode;var _eglInitialize=(display,majorVersion,minorVersion)=>{if(display!=62e3){EGL.setErrorCode(12296);/* EGL_BAD_DISPLAY */return 0}if(majorVersion){HEAP32[((majorVersion)>>2)]=1}// Advertise EGL Major version: '1'
if(minorVersion){HEAP32[((minorVersion)>>2)]=4}// Advertise EGL Minor version: '4'
EGL.defaultDisplayInitialized=true;EGL.setErrorCode(12288);/* EGL_SUCCESS */return 1};var _eglMakeCurrent=(display,draw,read,context)=>{if(display!=62e3){EGL.setErrorCode(12296);/* EGL_BAD_DISPLAY */return 0}//\todo An EGL_NOT_INITIALIZED error is generated if EGL is not initialized for dpy.
if(context!=0&&context!=62004){EGL.setErrorCode(12294);/* EGL_BAD_CONTEXT */return 0}if((read!=0&&read!=62006)||(draw!=0&&draw!=62006))/* Magic ID for Emscripten 'default surface' */{EGL.setErrorCode(12301);/* EGL_BAD_SURFACE */return 0}GL.makeContextCurrent(context?EGL.context:null);EGL.currentContext=context;EGL.currentDrawSurface=draw;EGL.currentReadSurface=read;EGL.setErrorCode(12288);/* EGL_SUCCESS */return 1};/* EGL_TRUE */var lengthBytesUTF8=str=>{var len=0;for(var i=0;i<str.length;++i){// Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code
// unit, not a Unicode code point of the character! So decode
// UTF16->UTF32->UTF8.
// See http://unicode.org/faq/utf_bom.html#utf16-3
var c=str.charCodeAt(i);// possibly a lead surrogate
if(c<=127){len++}else if(c<=2047){len+=2}else if(c>=55296&&c<=57343){len+=4;++i}else{len+=3}}return len};var stringToUTF8Array=(str,heap,outIdx,maxBytesToWrite)=>{// Parameter maxBytesToWrite is not optional. Negative values, 0, null,
// undefined and false each don't write out any bytes.
if(!(maxBytesToWrite>0))return 0;var startIdx=outIdx;var endIdx=outIdx+maxBytesToWrite-1;// -1 for string null terminator.
for(var i=0;i<str.length;++i){// Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code
// unit, not a Unicode code point of the character! So decode
// UTF16->UTF32->UTF8.
// See http://unicode.org/faq/utf_bom.html#utf16-3
// For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description
// and https://www.ietf.org/rfc/rfc2279.txt
// and https://tools.ietf.org/html/rfc3629
var u=str.charCodeAt(i);// possibly a lead surrogate
if(u>=55296&&u<=57343){var u1=str.charCodeAt(++i);u=65536+((u&1023)<<10)|(u1&1023)}if(u<=127){if(outIdx>=endIdx)break;heap[outIdx++]=u}else if(u<=2047){if(outIdx+1>=endIdx)break;heap[outIdx++]=192|(u>>6);heap[outIdx++]=128|(u&63)}else if(u<=65535){if(outIdx+2>=endIdx)break;heap[outIdx++]=224|(u>>12);heap[outIdx++]=128|((u>>6)&63);heap[outIdx++]=128|(u&63)}else{if(outIdx+3>=endIdx)break;heap[outIdx++]=240|(u>>18);heap[outIdx++]=128|((u>>12)&63);heap[outIdx++]=128|((u>>6)&63);heap[outIdx++]=128|(u&63)}}// Null-terminate the pointer to the buffer.
heap[outIdx]=0;return outIdx-startIdx};var stringToUTF8=(str,outPtr,maxBytesToWrite)=>stringToUTF8Array(str,HEAPU8,outPtr,maxBytesToWrite);var stringToNewUTF8=str=>{var size=lengthBytesUTF8(str)+1;var ret=_malloc(size);if(ret)stringToUTF8(str,ret,size);return ret};var _eglQueryString=(display,name)=>{if(display!=62e3){EGL.setErrorCode(12296);/* EGL_BAD_DISPLAY */return 0}//\todo An EGL_NOT_INITIALIZED error is generated if EGL is not initialized for dpy.
EGL.setErrorCode(12288);/* EGL_SUCCESS */if(EGL.stringCache[name])return EGL.stringCache[name];var ret;switch(name){case 12371:/* EGL_VENDOR */ret=stringToNewUTF8("Emscripten");break;case 12372:/* EGL_VERSION */ret=stringToNewUTF8("1.4 Emscripten EGL");break;case 12373:/* EGL_EXTENSIONS */ret=stringToNewUTF8("");break;// Currently not supporting any EGL extensions.
case 12429:/* EGL_CLIENT_APIS */ret=stringToNewUTF8("OpenGL_ES");break;default:EGL.setErrorCode(12300);/* EGL_BAD_PARAMETER */return 0}EGL.stringCache[name]=ret;return ret};var _eglSwapBuffers=(dpy,surface)=>{if(!EGL.defaultDisplayInitialized){EGL.setErrorCode(12289)}else/* EGL_NOT_INITIALIZED */if(!Module.ctx){EGL.setErrorCode(12290)}else/* EGL_BAD_ACCESS */if(Module.ctx.isContextLost()){EGL.setErrorCode(12302)}else/* EGL_CONTEXT_LOST */{// According to documentation this does an implicit flush.
// Due to discussion at https://github.com/emscripten-core/emscripten/pull/1871
// the flush was removed since this _may_ result in slowing code down.
//_glFlush();
EGL.setErrorCode(12288);/* EGL_SUCCESS */return 1}/* EGL_TRUE */return 0};/**
     * @param {number=} arg
     * @param {boolean=} noSetTiming
     */var setMainLoop=(iterFunc,fps,simulateInfiniteLoop,arg,noSetTiming)=>{MainLoop.func=iterFunc;MainLoop.arg=arg;var thisMainLoopId=MainLoop.currentlyRunningMainloop;function checkIsRunning(){if(thisMainLoopId<MainLoop.currentlyRunningMainloop){maybeExit();return false}return true}// We create the loop runner here but it is not actually running until
// _emscripten_set_main_loop_timing is called (which might happen a
// later time).  This member signifies that the current runner has not
// yet been started so that we can call runtimeKeepalivePush when it
// gets it timing set for the first time.
MainLoop.running=false;MainLoop.runner=function MainLoop_runner(){if(ABORT)return;if(MainLoop.queue.length>0){var start=Date.now();var blocker=MainLoop.queue.shift();blocker.func(blocker.arg);if(MainLoop.remainingBlockers){var remaining=MainLoop.remainingBlockers;var next=remaining%1==0?remaining-1:Math.floor(remaining);if(blocker.counted){MainLoop.remainingBlockers=next}else{// not counted, but move the progress along a tiny bit
next=next+.5;// do not steal all the next one's progress
MainLoop.remainingBlockers=(8*remaining+next)/9}}MainLoop.updateStatus();// catches pause/resume main loop from blocker execution
if(!checkIsRunning())return;setTimeout(MainLoop.runner,0);return}// catch pauses from non-main loop sources
if(!checkIsRunning())return;// Implement very basic swap interval control
MainLoop.currentFrameNumber=MainLoop.currentFrameNumber+1|0;if(MainLoop.timingMode==1&&MainLoop.timingValue>1&&MainLoop.currentFrameNumber%MainLoop.timingValue!=0){// Not the scheduled time to render this frame - skip.
MainLoop.scheduler();return}else if(MainLoop.timingMode==0){MainLoop.tickStartTime=_emscripten_get_now()}MainLoop.runIter(iterFunc);// catch pauses from the main loop itself
if(!checkIsRunning())return;MainLoop.scheduler()};if(!noSetTiming){if(fps&&fps>0){_emscripten_set_main_loop_timing(0,1e3/fps)}else{// Do rAF by rendering each frame (no decimating)
_emscripten_set_main_loop_timing(1,1)}MainLoop.scheduler()}if(simulateInfiniteLoop){throw"unwind"}};var MainLoop={running:false,scheduler:null,method:"",currentlyRunningMainloop:0,func:null,arg:0,timingMode:0,timingValue:0,currentFrameNumber:0,queue:[],preMainLoop:[],postMainLoop:[],pause(){MainLoop.scheduler=null;// Incrementing this signals the previous main loop that it's now become old, and it must return.
MainLoop.currentlyRunningMainloop++},resume(){MainLoop.currentlyRunningMainloop++;var timingMode=MainLoop.timingMode;var timingValue=MainLoop.timingValue;var func=MainLoop.func;MainLoop.func=null;// do not set timing and call scheduler, we will do it on the next lines
setMainLoop(func,0,false,MainLoop.arg,true);_emscripten_set_main_loop_timing(timingMode,timingValue);MainLoop.scheduler()},updateStatus(){},init(){},runIter(func){if(ABORT)return;for(var pre of MainLoop.preMainLoop){if(pre()===false){return}}// |return false| skips a frame
callUserCallback(func);for(var post of MainLoop.postMainLoop){post()}},nextRAF:0,fakeRequestAnimationFrame(func){// try to keep 60fps between calls to here
var now=Date.now();if(MainLoop.nextRAF===0){MainLoop.nextRAF=now+1e3/60}else{while(now+2>=MainLoop.nextRAF){// fudge a little, to avoid timer jitter causing us to do lots of delay:0
MainLoop.nextRAF+=1e3/60}}var delay=Math.max(MainLoop.nextRAF-now,0);setTimeout(func,delay)},requestAnimationFrame(func){if(typeof requestAnimationFrame=="function"){requestAnimationFrame(func);return}var RAF=MainLoop.fakeRequestAnimationFrame;RAF(func)}};var _emscripten_set_main_loop_timing=(mode,value)=>{MainLoop.timingMode=mode;MainLoop.timingValue=value;if(!MainLoop.func){return 1}// Return non-zero on failure, can't set timing mode when there is no main loop.
if(!MainLoop.running){MainLoop.running=true}if(mode==0){MainLoop.scheduler=function MainLoop_scheduler_setTimeout(){var timeUntilNextTick=Math.max(0,MainLoop.tickStartTime+value-_emscripten_get_now())|0;setTimeout(MainLoop.runner,timeUntilNextTick)};// doing this each time means that on exception, we stop
MainLoop.method="timeout"}else if(mode==1){MainLoop.scheduler=function MainLoop_scheduler_rAF(){MainLoop.requestAnimationFrame(MainLoop.runner)};MainLoop.method="rAF"}else if(mode==2){if(typeof MainLoop.setImmediate=="undefined"){if(typeof setImmediate=="undefined"){// Emulate setImmediate. (note: not a complete polyfill, we don't emulate clearImmediate() to keep code size to minimum, since not needed)
var setImmediates=[];var emscriptenMainLoopMessageId="setimmediate";/** @param {Event} event */var MainLoop_setImmediate_messageHandler=event=>{// When called in current thread or Worker, the main loop ID is structured slightly different to accommodate for --proxy-to-worker runtime listening to Worker events,
// so check for both cases.
if(event.data===emscriptenMainLoopMessageId||event.data.target===emscriptenMainLoopMessageId){event.stopPropagation();setImmediates.shift()()}};addEventListener("message",MainLoop_setImmediate_messageHandler,true);MainLoop.setImmediate=/** @type{function(function(): ?, ...?): number} */(func=>{setImmediates.push(func);if(ENVIRONMENT_IS_WORKER){Module["setImmediates"]??=[];Module["setImmediates"].push(func);postMessage({target:emscriptenMainLoopMessageId})}else// In --proxy-to-worker, route the message via proxyClient.js
postMessage(emscriptenMainLoopMessageId,"*")})}else{MainLoop.setImmediate=setImmediate}}MainLoop.scheduler=function MainLoop_scheduler_setImmediate(){MainLoop.setImmediate(MainLoop.runner)};MainLoop.method="immediate"}return 0};var _eglSwapInterval=(display,interval)=>{if(display!=62e3){EGL.setErrorCode(12296);/* EGL_BAD_DISPLAY */return 0}if(interval==0)_emscripten_set_main_loop_timing(0,0);else _emscripten_set_main_loop_timing(1,interval);EGL.setErrorCode(12288);/* EGL_SUCCESS */return 1};var _eglTerminate=display=>{if(display!=62e3){EGL.setErrorCode(12296);/* EGL_BAD_DISPLAY */return 0}EGL.currentContext=0;EGL.currentReadSurface=0;EGL.currentDrawSurface=0;EGL.defaultDisplayInitialized=false;EGL.setErrorCode(12288);/* EGL_SUCCESS */return 1};/** @suppress {duplicate } */var _eglWaitClient=()=>{EGL.setErrorCode(12288);/* EGL_SUCCESS */return 1};var _eglWaitGL=_eglWaitClient;var _eglWaitNative=nativeEngineId=>{EGL.setErrorCode(12288);/* EGL_SUCCESS */return 1};var readEmAsmArgsArray=[];var readEmAsmArgs=(sigPtr,buf)=>{readEmAsmArgsArray.length=0;var ch;// Most arguments are i32s, so shift the buffer pointer so it is a plain
// index into HEAP32.
while(ch=HEAPU8[sigPtr++]){// Floats are always passed as doubles, so all types except for 'i'
// are 8 bytes and require alignment.
var wide=(ch!=105);wide&=(ch!=112);buf+=wide&&(buf%8)?4:0;readEmAsmArgsArray.push(// Special case for pointers under wasm64 or CAN_ADDRESS_2GB mode.
ch==112?HEAPU32[((buf)>>2)]:ch==105?HEAP32[((buf)>>2)]:HEAPF64[((buf)>>3)]);buf+=wide?8:4}return readEmAsmArgsArray};var runEmAsmFunction=(code,sigPtr,argbuf)=>{var args=readEmAsmArgs(sigPtr,argbuf);return ASM_CONSTS[code](...args)};var _emscripten_asm_const_int=(code,sigPtr,argbuf)=>runEmAsmFunction(code,sigPtr,argbuf);var runMainThreadEmAsm=(emAsmAddr,sigPtr,argbuf,sync)=>{var args=readEmAsmArgs(sigPtr,argbuf);return ASM_CONSTS[emAsmAddr](...args)};var _emscripten_asm_const_int_sync_on_main_thread=(emAsmAddr,sigPtr,argbuf)=>runMainThreadEmAsm(emAsmAddr,sigPtr,argbuf,1);var _emscripten_asm_const_ptr_sync_on_main_thread=(emAsmAddr,sigPtr,argbuf)=>runMainThreadEmAsm(emAsmAddr,sigPtr,argbuf,1);var _emscripten_cancel_main_loop=()=>{MainLoop.pause();MainLoop.func=null};var _emscripten_date_now=()=>Date.now();var JSEvents={batteryEvent:0,gamepadEvent:0,keyEvent:0,mouseEvent:0,wheelEvent:0,uiEvent:0,focusEvent:0,deviceOrientationEvent:0,orientationChangeEvent:0,deviceMotionEvent:0,fullscreenChangeEvent:0,pointerlockChangeEvent:0,visibilityChangeEvent:0,touchEvent:0,removeAllEventListeners(){while(JSEvents.eventHandlers.length){JSEvents._removeHandler(JSEvents.eventHandlers.length-1)}JSEvents.deferredCalls=[]},inEventHandler:0,deferredCalls:[],deferCall(targetFunction,precedence,argsList){function arraysHaveEqualContent(arrA,arrB){if(arrA.length!=arrB.length)return false;for(var i in arrA){if(arrA[i]!=arrB[i])return false}return true}// Test if the given call was already queued, and if so, don't add it again.
for(var call of JSEvents.deferredCalls){if(call.targetFunction==targetFunction&&arraysHaveEqualContent(call.argsList,argsList)){return}}JSEvents.deferredCalls.push({targetFunction,precedence,argsList});JSEvents.deferredCalls.sort((x,y)=>x.precedence<y.precedence)},removeDeferredCalls(targetFunction){JSEvents.deferredCalls=JSEvents.deferredCalls.filter(call=>call.targetFunction!=targetFunction)},canPerformEventHandlerRequests(){if(navigator.userActivation){// Verify against transient activation status from UserActivation API
// whether it is possible to perform a request here without needing to defer. See
// https://developer.mozilla.org/en-US/docs/Web/Security/User_activation#transient_activation
// and https://caniuse.com/mdn-api_useractivation
// At the time of writing, Firefox does not support this API: https://bugzilla.mozilla.org/show_bug.cgi?id=1791079
return navigator.userActivation.isActive}return JSEvents.inEventHandler&&JSEvents.currentEventHandler.allowsDeferredCalls},runDeferredCalls(){if(!JSEvents.canPerformEventHandlerRequests()){return}var deferredCalls=JSEvents.deferredCalls;JSEvents.deferredCalls=[];for(var call of deferredCalls){call.targetFunction(...call.argsList)}},eventHandlers:[],removeAllHandlersOnTarget:(target,eventTypeString)=>{for(var i=0;i<JSEvents.eventHandlers.length;++i){if(JSEvents.eventHandlers[i].target==target&&(!eventTypeString||eventTypeString==JSEvents.eventHandlers[i].eventTypeString)){JSEvents._removeHandler(i--)}}},_removeHandler(i){var h=JSEvents.eventHandlers[i];h.target.removeEventListener(h.eventTypeString,h.eventListenerFunc,h.useCapture);JSEvents.eventHandlers.splice(i,1)},registerOrRemoveHandler(eventHandler){if(!eventHandler.target){return-4}if(eventHandler.callbackfunc){eventHandler.eventListenerFunc=function(event){// Increment nesting count for the event handler.
++JSEvents.inEventHandler;JSEvents.currentEventHandler=eventHandler;// Process any old deferred calls the user has placed.
JSEvents.runDeferredCalls();// Process the actual event, calls back to user C code handler.
eventHandler.handlerFunc(event);// Process any new deferred calls that were placed right now from this event handler.
JSEvents.runDeferredCalls();// Out of event handler - restore nesting count.
--JSEvents.inEventHandler};eventHandler.target.addEventListener(eventHandler.eventTypeString,eventHandler.eventListenerFunc,eventHandler.useCapture);JSEvents.eventHandlers.push(eventHandler)}else{for(var i=0;i<JSEvents.eventHandlers.length;++i){if(JSEvents.eventHandlers[i].target==eventHandler.target&&JSEvents.eventHandlers[i].eventTypeString==eventHandler.eventTypeString){JSEvents._removeHandler(i--)}}}return 0},getNodeNameForTarget(target){if(!target)return"";if(target==window)return"#window";if(target==screen)return"#screen";return target?.nodeName||""},fullscreenEnabled(){return document.fullscreenEnabled||// Safari 13.0.3 on macOS Catalina 10.15.1 still ships with prefixed webkitFullscreenEnabled.
// TODO: If Safari at some point ships with unprefixed version, update the version check above.
document.webkitFullscreenEnabled}};var currentFullscreenStrategy={};var maybeCStringToJsString=cString=>cString>2?UTF8ToString(cString):cString;/** @type {Object} */var specialHTMLTargets=[0,document,window];/** @suppress {duplicate } */var findEventTarget=target=>{target=maybeCStringToJsString(target);var domElement=specialHTMLTargets[target]||document.querySelector(target);return domElement};var findCanvasEventTarget=findEventTarget;var _emscripten_get_canvas_element_size=(target,width,height)=>{var canvas=findCanvasEventTarget(target);if(!canvas)return-4;HEAP32[((width)>>2)]=canvas.width;HEAP32[((height)>>2)]=canvas.height};var stackAlloc=sz=>__emscripten_stack_alloc(sz);var stringToUTF8OnStack=str=>{var size=lengthBytesUTF8(str)+1;var ret=stackAlloc(size);stringToUTF8(str,ret,size);return ret};var getCanvasElementSize=target=>{var sp=stackSave();var w=stackAlloc(8);var h=w+4;var targetInt=stringToUTF8OnStack(target.id);var ret=_emscripten_get_canvas_element_size(targetInt,w,h);var size=[HEAP32[((w)>>2)],HEAP32[((h)>>2)]];stackRestore(sp);return size};var _emscripten_set_canvas_element_size=(target,width,height)=>{var canvas=findCanvasEventTarget(target);if(!canvas)return-4;canvas.width=width;canvas.height=height;return 0};var setCanvasElementSize=(target,width,height)=>{if(!target.controlTransferredOffscreen){target.width=width;target.height=height}else{// This function is being called from high-level JavaScript code instead of asm.js/Wasm,
// and it needs to synchronously proxy over to another thread, so marshal the string onto the heap to do the call.
var sp=stackSave();var targetInt=stringToUTF8OnStack(target.id);_emscripten_set_canvas_element_size(targetInt,width,height);stackRestore(sp)}};var registerRestoreOldStyle=canvas=>{var canvasSize=getCanvasElementSize(canvas);var oldWidth=canvasSize[0];var oldHeight=canvasSize[1];var oldCssWidth=canvas.style.width;var oldCssHeight=canvas.style.height;var oldBackgroundColor=canvas.style.backgroundColor;// Chrome reads color from here.
var oldDocumentBackgroundColor=document.body.style.backgroundColor;// IE11 reads color from here.
// Firefox always has black background color.
var oldPaddingLeft=canvas.style.paddingLeft;// Chrome, FF, Safari
var oldPaddingRight=canvas.style.paddingRight;var oldPaddingTop=canvas.style.paddingTop;var oldPaddingBottom=canvas.style.paddingBottom;var oldMarginLeft=canvas.style.marginLeft;// IE11
var oldMarginRight=canvas.style.marginRight;var oldMarginTop=canvas.style.marginTop;var oldMarginBottom=canvas.style.marginBottom;var oldDocumentBodyMargin=document.body.style.margin;var oldDocumentOverflow=document.documentElement.style.overflow;// Chrome, Firefox
var oldDocumentScroll=document.body.scroll;// IE
var oldImageRendering=canvas.style.imageRendering;function restoreOldStyle(){var fullscreenElement=document.fullscreenElement||document.webkitFullscreenElement;if(!fullscreenElement){document.removeEventListener("fullscreenchange",restoreOldStyle);// Unprefixed Fullscreen API shipped in Chromium 71 (https://bugs.chromium.org/p/chromium/issues/detail?id=383813)
// As of Safari 13.0.3 on macOS Catalina 10.15.1 still ships with prefixed webkitfullscreenchange. TODO: revisit this check once Safari ships unprefixed version.
document.removeEventListener("webkitfullscreenchange",restoreOldStyle);setCanvasElementSize(canvas,oldWidth,oldHeight);canvas.style.width=oldCssWidth;canvas.style.height=oldCssHeight;canvas.style.backgroundColor=oldBackgroundColor;// Chrome
// IE11 hack: assigning 'undefined' or an empty string to document.body.style.backgroundColor has no effect, so first assign back the default color
// before setting the undefined value. Setting undefined value is also important, or otherwise we would later treat that as something that the user
// had explicitly set so subsequent fullscreen transitions would not set background color properly.
if(!oldDocumentBackgroundColor)document.body.style.backgroundColor="white";document.body.style.backgroundColor=oldDocumentBackgroundColor;// IE11
canvas.style.paddingLeft=oldPaddingLeft;// Chrome, FF, Safari
canvas.style.paddingRight=oldPaddingRight;canvas.style.paddingTop=oldPaddingTop;canvas.style.paddingBottom=oldPaddingBottom;canvas.style.marginLeft=oldMarginLeft;// IE11
canvas.style.marginRight=oldMarginRight;canvas.style.marginTop=oldMarginTop;canvas.style.marginBottom=oldMarginBottom;document.body.style.margin=oldDocumentBodyMargin;document.documentElement.style.overflow=oldDocumentOverflow;// Chrome, Firefox
document.body.scroll=oldDocumentScroll;// IE
canvas.style.imageRendering=oldImageRendering;if(canvas.GLctxObject)canvas.GLctxObject.GLctx.viewport(0,0,oldWidth,oldHeight);if(currentFullscreenStrategy.canvasResizedCallback){((a1,a2,a3)=>dynCall_iiii(currentFullscreenStrategy.canvasResizedCallback,a1,a2,a3))(37,0,currentFullscreenStrategy.canvasResizedCallbackUserData)}}}document.addEventListener("fullscreenchange",restoreOldStyle);// Unprefixed Fullscreen API shipped in Chromium 71 (https://bugs.chromium.org/p/chromium/issues/detail?id=383813)
// As of Safari 13.0.3 on macOS Catalina 10.15.1 still ships with prefixed webkitfullscreenchange. TODO: revisit this check once Safari ships unprefixed version.
document.addEventListener("webkitfullscreenchange",restoreOldStyle);return restoreOldStyle};var setLetterbox=(element,topBottom,leftRight)=>{// Cannot use margin to specify letterboxes in FF or Chrome, since those ignore margins in fullscreen mode.
element.style.paddingLeft=element.style.paddingRight=leftRight+"px";element.style.paddingTop=element.style.paddingBottom=topBottom+"px"};var getBoundingClientRect=e=>specialHTMLTargets.indexOf(e)<0?e.getBoundingClientRect():{"left":0,"top":0};var JSEvents_resizeCanvasForFullscreen=(target,strategy)=>{var restoreOldStyle=registerRestoreOldStyle(target);var cssWidth=strategy.softFullscreen?innerWidth:screen.width;var cssHeight=strategy.softFullscreen?innerHeight:screen.height;var rect=getBoundingClientRect(target);var windowedCssWidth=rect.width;var windowedCssHeight=rect.height;var canvasSize=getCanvasElementSize(target);var windowedRttWidth=canvasSize[0];var windowedRttHeight=canvasSize[1];if(strategy.scaleMode==3){setLetterbox(target,(cssHeight-windowedCssHeight)/2,(cssWidth-windowedCssWidth)/2);cssWidth=windowedCssWidth;cssHeight=windowedCssHeight}else if(strategy.scaleMode==2){if(cssWidth*windowedRttHeight<windowedRttWidth*cssHeight){var desiredCssHeight=windowedRttHeight*cssWidth/windowedRttWidth;setLetterbox(target,(cssHeight-desiredCssHeight)/2,0);cssHeight=desiredCssHeight}else{var desiredCssWidth=windowedRttWidth*cssHeight/windowedRttHeight;setLetterbox(target,0,(cssWidth-desiredCssWidth)/2);cssWidth=desiredCssWidth}}// If we are adding padding, must choose a background color or otherwise Chrome will give the
// padding a default white color. Do it only if user has not customized their own background color.
target.style.backgroundColor||="black";// IE11 does the same, but requires the color to be set in the document body.
document.body.style.backgroundColor||="black";// IE11
// Firefox always shows black letterboxes independent of style color.
target.style.width=cssWidth+"px";target.style.height=cssHeight+"px";if(strategy.filteringMode==1){target.style.imageRendering="optimizeSpeed";target.style.imageRendering="-moz-crisp-edges";target.style.imageRendering="-o-crisp-edges";target.style.imageRendering="-webkit-optimize-contrast";target.style.imageRendering="optimize-contrast";target.style.imageRendering="crisp-edges";target.style.imageRendering="pixelated"}var dpiScale=(strategy.canvasResolutionScaleMode==2)?devicePixelRatio:1;if(strategy.canvasResolutionScaleMode!=0){var newWidth=(cssWidth*dpiScale)|0;var newHeight=(cssHeight*dpiScale)|0;setCanvasElementSize(target,newWidth,newHeight);if(target.GLctxObject)target.GLctxObject.GLctx.viewport(0,0,newWidth,newHeight)}return restoreOldStyle};var JSEvents_requestFullscreen=(target,strategy)=>{// EMSCRIPTEN_FULLSCREEN_SCALE_DEFAULT + EMSCRIPTEN_FULLSCREEN_CANVAS_SCALE_NONE is a mode where no extra logic is performed to the DOM elements.
if(strategy.scaleMode!=0||strategy.canvasResolutionScaleMode!=0){JSEvents_resizeCanvasForFullscreen(target,strategy)}if(target.requestFullscreen){target.requestFullscreen()}else if(target.webkitRequestFullscreen){target.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT)}else{return JSEvents.fullscreenEnabled()?-3:-1}currentFullscreenStrategy=strategy;if(strategy.canvasResizedCallback){((a1,a2,a3)=>dynCall_iiii(strategy.canvasResizedCallback,a1,a2,a3))(37,0,strategy.canvasResizedCallbackUserData)}return 0};var _emscripten_exit_fullscreen=()=>{if(!JSEvents.fullscreenEnabled())return-1;// Make sure no queued up calls will fire after this.
JSEvents.removeDeferredCalls(JSEvents_requestFullscreen);var d=specialHTMLTargets[1];if(d.exitFullscreen){d.fullscreenElement&&d.exitFullscreen()}else if(d.webkitExitFullscreen){d.webkitFullscreenElement&&d.webkitExitFullscreen()}else{return-1}return 0};var requestPointerLock=target=>{if(target.requestPointerLock){target.requestPointerLock()}else{// document.body is known to accept pointer lock, so use that to differentiate if the user passed a bad element,
// or if the whole browser just doesn't support the feature.
if(document.body.requestPointerLock){return-3}return-1}return 0};var _emscripten_exit_pointerlock=()=>{// Make sure no queued up calls will fire after this.
JSEvents.removeDeferredCalls(requestPointerLock);if(document.exitPointerLock){document.exitPointerLock()}else{return-1}return 0};var _emscripten_force_exit=status=>{__emscripten_runtime_keepalive_clear();_exit(status)};var _emscripten_get_device_pixel_ratio=()=>devicePixelRatio;var _emscripten_get_element_css_size=(target,width,height)=>{target=findEventTarget(target);if(!target)return-4;var rect=getBoundingClientRect(target);HEAPF64[((width)>>3)]=rect.width;HEAPF64[((height)>>3)]=rect.height;return 0};var fillGamepadEventData=(eventStruct,e)=>{HEAPF64[((eventStruct)>>3)]=e.timestamp;for(var i=0;i<e.axes.length;++i){HEAPF64[(((eventStruct+i*8)+(16))>>3)]=e.axes[i]}for(var i=0;i<e.buttons.length;++i){if(typeof e.buttons[i]=="object"){HEAPF64[(((eventStruct+i*8)+(528))>>3)]=e.buttons[i].value}else{HEAPF64[(((eventStruct+i*8)+(528))>>3)]=e.buttons[i]}}for(var i=0;i<e.buttons.length;++i){if(typeof e.buttons[i]=="object"){HEAP8[(eventStruct+i)+(1040)]=e.buttons[i].pressed}else{// Assigning a boolean to HEAP32, that's ok, but Closure would like to warn about it:
/** @suppress {checkTypes} */HEAP8[(eventStruct+i)+(1040)]=e.buttons[i]==1}}HEAP8[(eventStruct)+(1104)]=e.connected;HEAP32[(((eventStruct)+(1108))>>2)]=e.index;HEAP32[(((eventStruct)+(8))>>2)]=e.axes.length;HEAP32[(((eventStruct)+(12))>>2)]=e.buttons.length;stringToUTF8(e.id,eventStruct+1112,64);stringToUTF8(e.mapping,eventStruct+1176,64)};var _emscripten_get_gamepad_status=(index,gamepadState)=>{// INVALID_PARAM is returned on a Gamepad index that never was there.
if(index<0||index>=JSEvents.lastGamepadState.length)return-5;// NO_DATA is returned on a Gamepad index that was removed.
// For previously disconnected gamepads there should be an empty slot (null/undefined/false) at the index.
// This is because gamepads must keep their original position in the array.
// For example, removing the first of two gamepads produces [null/undefined/false, gamepad].
if(!JSEvents.lastGamepadState[index])return-7;fillGamepadEventData(gamepadState,JSEvents.lastGamepadState[index]);return 0};var _emscripten_get_num_gamepads=()=>JSEvents.lastGamepadState.length;var _emscripten_get_screen_size=(width,height)=>{HEAP32[((width)>>2)]=screen.width;HEAP32[((height)>>2)]=screen.height};/** @suppress {duplicate } */var _glActiveTexture=x0=>GLctx.activeTexture(x0);var _emscripten_glActiveTexture=_glActiveTexture;/** @suppress {duplicate } */var _glAttachShader=(program,shader)=>{GLctx.attachShader(GL.programs[program],GL.shaders[shader])};var _emscripten_glAttachShader=_glAttachShader;/** @suppress {duplicate } */var _glBeginQueryEXT=(target,id)=>{GLctx.disjointTimerQueryExt["beginQueryEXT"](target,GL.queries[id])};var _emscripten_glBeginQueryEXT=_glBeginQueryEXT;/** @suppress {duplicate } */var _glBindAttribLocation=(program,index,name)=>{GLctx.bindAttribLocation(GL.programs[program],index,UTF8ToString(name))};var _emscripten_glBindAttribLocation=_glBindAttribLocation;/** @suppress {duplicate } */var _glBindBuffer=(target,buffer)=>{GLctx.bindBuffer(target,GL.buffers[buffer])};var _emscripten_glBindBuffer=_glBindBuffer;/** @suppress {duplicate } */var _glBindFramebuffer=(target,framebuffer)=>{GLctx.bindFramebuffer(target,GL.framebuffers[framebuffer])};var _emscripten_glBindFramebuffer=_glBindFramebuffer;/** @suppress {duplicate } */var _glBindRenderbuffer=(target,renderbuffer)=>{GLctx.bindRenderbuffer(target,GL.renderbuffers[renderbuffer])};var _emscripten_glBindRenderbuffer=_glBindRenderbuffer;/** @suppress {duplicate } */var _glBindTexture=(target,texture)=>{GLctx.bindTexture(target,GL.textures[texture])};var _emscripten_glBindTexture=_glBindTexture;/** @suppress {duplicate } */var _glBindVertexArray=vao=>{GLctx.bindVertexArray(GL.vaos[vao])};/** @suppress {duplicate } */var _glBindVertexArrayOES=_glBindVertexArray;var _emscripten_glBindVertexArrayOES=_glBindVertexArrayOES;/** @suppress {duplicate } */var _glBlendColor=(x0,x1,x2,x3)=>GLctx.blendColor(x0,x1,x2,x3);var _emscripten_glBlendColor=_glBlendColor;/** @suppress {duplicate } */var _glBlendEquation=x0=>GLctx.blendEquation(x0);var _emscripten_glBlendEquation=_glBlendEquation;/** @suppress {duplicate } */var _glBlendEquationSeparate=(x0,x1)=>GLctx.blendEquationSeparate(x0,x1);var _emscripten_glBlendEquationSeparate=_glBlendEquationSeparate;/** @suppress {duplicate } */var _glBlendFunc=(x0,x1)=>GLctx.blendFunc(x0,x1);var _emscripten_glBlendFunc=_glBlendFunc;/** @suppress {duplicate } */var _glBlendFuncSeparate=(x0,x1,x2,x3)=>GLctx.blendFuncSeparate(x0,x1,x2,x3);var _emscripten_glBlendFuncSeparate=_glBlendFuncSeparate;/** @suppress {duplicate } */var _glBufferData=(target,size,data,usage)=>{// N.b. here first form specifies a heap subarray, second form an integer
// size, so the ?: code here is polymorphic. It is advised to avoid
// randomly mixing both uses in calling code, to avoid any potential JS
// engine JIT issues.
GLctx.bufferData(target,data?HEAPU8.subarray(data,data+size):size,usage)};var _emscripten_glBufferData=_glBufferData;/** @suppress {duplicate } */var _glBufferSubData=(target,offset,size,data)=>{GLctx.bufferSubData(target,offset,HEAPU8.subarray(data,data+size))};var _emscripten_glBufferSubData=_glBufferSubData;/** @suppress {duplicate } */var _glCheckFramebufferStatus=x0=>GLctx.checkFramebufferStatus(x0);var _emscripten_glCheckFramebufferStatus=_glCheckFramebufferStatus;/** @suppress {duplicate } */var _glClear=x0=>GLctx.clear(x0);var _emscripten_glClear=_glClear;/** @suppress {duplicate } */var _glClearColor=(x0,x1,x2,x3)=>GLctx.clearColor(x0,x1,x2,x3);var _emscripten_glClearColor=_glClearColor;/** @suppress {duplicate } */var _glClearDepthf=x0=>GLctx.clearDepth(x0);var _emscripten_glClearDepthf=_glClearDepthf;/** @suppress {duplicate } */var _glClearStencil=x0=>GLctx.clearStencil(x0);var _emscripten_glClearStencil=_glClearStencil;/** @suppress {duplicate } */var _glClipControlEXT=(origin,depth)=>{GLctx.extClipControl["clipControlEXT"](origin,depth)};var _emscripten_glClipControlEXT=_glClipControlEXT;/** @suppress {duplicate } */var _glColorMask=(red,green,blue,alpha)=>{GLctx.colorMask(!!red,!!green,!!blue,!!alpha)};var _emscripten_glColorMask=_glColorMask;/** @suppress {duplicate } */var _glCompileShader=shader=>{GLctx.compileShader(GL.shaders[shader])};var _emscripten_glCompileShader=_glCompileShader;/** @suppress {duplicate } */var _glCompressedTexImage2D=(target,level,internalFormat,width,height,border,imageSize,data)=>{// `data` may be null here, which means "allocate uniniitalized space but
// don't upload" in GLES parlance, but `compressedTexImage2D` requires the
// final data parameter, so we simply pass a heap view starting at zero
// effectively uploading whatever happens to be near address zero.  See
// https://github.com/emscripten-core/emscripten/issues/19300.
GLctx.compressedTexImage2D(target,level,internalFormat,width,height,border,HEAPU8.subarray((data),data+imageSize))};var _emscripten_glCompressedTexImage2D=_glCompressedTexImage2D;/** @suppress {duplicate } */var _glCompressedTexSubImage2D=(target,level,xoffset,yoffset,width,height,format,imageSize,data)=>{GLctx.compressedTexSubImage2D(target,level,xoffset,yoffset,width,height,format,HEAPU8.subarray((data),data+imageSize))};var _emscripten_glCompressedTexSubImage2D=_glCompressedTexSubImage2D;/** @suppress {duplicate } */var _glCopyTexImage2D=(x0,x1,x2,x3,x4,x5,x6,x7)=>GLctx.copyTexImage2D(x0,x1,x2,x3,x4,x5,x6,x7);var _emscripten_glCopyTexImage2D=_glCopyTexImage2D;/** @suppress {duplicate } */var _glCopyTexSubImage2D=(x0,x1,x2,x3,x4,x5,x6,x7)=>GLctx.copyTexSubImage2D(x0,x1,x2,x3,x4,x5,x6,x7);var _emscripten_glCopyTexSubImage2D=_glCopyTexSubImage2D;/** @suppress {duplicate } */var _glCreateProgram=()=>{var id=GL.getNewId(GL.programs);var program=GLctx.createProgram();// Store additional information needed for each shader program:
program.name=id;// Lazy cache results of
// glGetProgramiv(GL_ACTIVE_UNIFORM_MAX_LENGTH/GL_ACTIVE_ATTRIBUTE_MAX_LENGTH/GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH)
program.maxUniformLength=program.maxAttributeLength=program.maxUniformBlockNameLength=0;program.uniformIdCounter=1;GL.programs[id]=program;return id};var _emscripten_glCreateProgram=_glCreateProgram;/** @suppress {duplicate } */var _glCreateShader=shaderType=>{var id=GL.getNewId(GL.shaders);GL.shaders[id]=GLctx.createShader(shaderType);return id};var _emscripten_glCreateShader=_glCreateShader;/** @suppress {duplicate } */var _glCullFace=x0=>GLctx.cullFace(x0);var _emscripten_glCullFace=_glCullFace;/** @suppress {duplicate } */var _glDeleteBuffers=(n,buffers)=>{for(var i=0;i<n;i++){var id=HEAP32[(((buffers)+(i*4))>>2)];var buffer=GL.buffers[id];// From spec: "glDeleteBuffers silently ignores 0's and names that do not
// correspond to existing buffer objects."
if(!buffer)continue;GLctx.deleteBuffer(buffer);buffer.name=0;GL.buffers[id]=null}};var _emscripten_glDeleteBuffers=_glDeleteBuffers;/** @suppress {duplicate } */var _glDeleteFramebuffers=(n,framebuffers)=>{for(var i=0;i<n;++i){var id=HEAP32[(((framebuffers)+(i*4))>>2)];var framebuffer=GL.framebuffers[id];if(!framebuffer)continue;// GL spec: "glDeleteFramebuffers silently ignores 0s and names that do not correspond to existing framebuffer objects".
GLctx.deleteFramebuffer(framebuffer);framebuffer.name=0;GL.framebuffers[id]=null}};var _emscripten_glDeleteFramebuffers=_glDeleteFramebuffers;/** @suppress {duplicate } */var _glDeleteProgram=id=>{if(!id)return;var program=GL.programs[id];if(!program){// glDeleteProgram actually signals an error when deleting a nonexisting
// object, unlike some other GL delete functions.
GL.recordError(1281);/* GL_INVALID_VALUE */return}GLctx.deleteProgram(program);program.name=0;GL.programs[id]=null};var _emscripten_glDeleteProgram=_glDeleteProgram;/** @suppress {duplicate } */var _glDeleteQueriesEXT=(n,ids)=>{for(var i=0;i<n;i++){var id=HEAP32[(((ids)+(i*4))>>2)];var query=GL.queries[id];if(!query)continue;// GL spec: "unused names in ids are ignored, as is the name zero."
GLctx.disjointTimerQueryExt["deleteQueryEXT"](query);GL.queries[id]=null}};var _emscripten_glDeleteQueriesEXT=_glDeleteQueriesEXT;/** @suppress {duplicate } */var _glDeleteRenderbuffers=(n,renderbuffers)=>{for(var i=0;i<n;i++){var id=HEAP32[(((renderbuffers)+(i*4))>>2)];var renderbuffer=GL.renderbuffers[id];if(!renderbuffer)continue;// GL spec: "glDeleteRenderbuffers silently ignores 0s and names that do not correspond to existing renderbuffer objects".
GLctx.deleteRenderbuffer(renderbuffer);renderbuffer.name=0;GL.renderbuffers[id]=null}};var _emscripten_glDeleteRenderbuffers=_glDeleteRenderbuffers;/** @suppress {duplicate } */var _glDeleteShader=id=>{if(!id)return;var shader=GL.shaders[id];if(!shader){// glDeleteShader actually signals an error when deleting a nonexisting
// object, unlike some other GL delete functions.
GL.recordError(1281);/* GL_INVALID_VALUE */return}GLctx.deleteShader(shader);GL.shaders[id]=null};var _emscripten_glDeleteShader=_glDeleteShader;/** @suppress {duplicate } */var _glDeleteTextures=(n,textures)=>{for(var i=0;i<n;i++){var id=HEAP32[(((textures)+(i*4))>>2)];var texture=GL.textures[id];// GL spec: "glDeleteTextures silently ignores 0s and names that do not
// correspond to existing textures".
if(!texture)continue;GLctx.deleteTexture(texture);texture.name=0;GL.textures[id]=null}};var _emscripten_glDeleteTextures=_glDeleteTextures;/** @suppress {duplicate } */var _glDeleteVertexArrays=(n,vaos)=>{for(var i=0;i<n;i++){var id=HEAP32[(((vaos)+(i*4))>>2)];GLctx.deleteVertexArray(GL.vaos[id]);GL.vaos[id]=null}};/** @suppress {duplicate } */var _glDeleteVertexArraysOES=_glDeleteVertexArrays;var _emscripten_glDeleteVertexArraysOES=_glDeleteVertexArraysOES;/** @suppress {duplicate } */var _glDepthFunc=x0=>GLctx.depthFunc(x0);var _emscripten_glDepthFunc=_glDepthFunc;/** @suppress {duplicate } */var _glDepthMask=flag=>{GLctx.depthMask(!!flag)};var _emscripten_glDepthMask=_glDepthMask;/** @suppress {duplicate } */var _glDepthRangef=(x0,x1)=>GLctx.depthRange(x0,x1);var _emscripten_glDepthRangef=_glDepthRangef;/** @suppress {duplicate } */var _glDetachShader=(program,shader)=>{GLctx.detachShader(GL.programs[program],GL.shaders[shader])};var _emscripten_glDetachShader=_glDetachShader;/** @suppress {duplicate } */var _glDisable=x0=>GLctx.disable(x0);var _emscripten_glDisable=_glDisable;/** @suppress {duplicate } */var _glDisableVertexAttribArray=index=>{GLctx.disableVertexAttribArray(index)};var _emscripten_glDisableVertexAttribArray=_glDisableVertexAttribArray;/** @suppress {duplicate } */var _glDrawArrays=(mode,first,count)=>{GLctx.drawArrays(mode,first,count)};var _emscripten_glDrawArrays=_glDrawArrays;/** @suppress {duplicate } */var _glDrawArraysInstanced=(mode,first,count,primcount)=>{GLctx.drawArraysInstanced(mode,first,count,primcount)};/** @suppress {duplicate } */var _glDrawArraysInstancedANGLE=_glDrawArraysInstanced;var _emscripten_glDrawArraysInstancedANGLE=_glDrawArraysInstancedANGLE;var tempFixedLengthArray=[];/** @suppress {duplicate } */var _glDrawBuffers=(n,bufs)=>{var bufArray=tempFixedLengthArray[n];for(var i=0;i<n;i++){bufArray[i]=HEAP32[(((bufs)+(i*4))>>2)]}GLctx.drawBuffers(bufArray)};/** @suppress {duplicate } */var _glDrawBuffersWEBGL=_glDrawBuffers;var _emscripten_glDrawBuffersWEBGL=_glDrawBuffersWEBGL;/** @suppress {duplicate } */var _glDrawElements=(mode,count,type,indices)=>{GLctx.drawElements(mode,count,type,indices)};var _emscripten_glDrawElements=_glDrawElements;/** @suppress {duplicate } */var _glDrawElementsInstanced=(mode,count,type,indices,primcount)=>{GLctx.drawElementsInstanced(mode,count,type,indices,primcount)};/** @suppress {duplicate } */var _glDrawElementsInstancedANGLE=_glDrawElementsInstanced;var _emscripten_glDrawElementsInstancedANGLE=_glDrawElementsInstancedANGLE;/** @suppress {duplicate } */var _glEnable=x0=>GLctx.enable(x0);var _emscripten_glEnable=_glEnable;/** @suppress {duplicate } */var _glEnableVertexAttribArray=index=>{GLctx.enableVertexAttribArray(index)};var _emscripten_glEnableVertexAttribArray=_glEnableVertexAttribArray;/** @suppress {duplicate } */var _glEndQueryEXT=target=>{GLctx.disjointTimerQueryExt["endQueryEXT"](target)};var _emscripten_glEndQueryEXT=_glEndQueryEXT;/** @suppress {duplicate } */var _glFinish=()=>GLctx.finish();var _emscripten_glFinish=_glFinish;/** @suppress {duplicate } */var _glFlush=()=>GLctx.flush();var _emscripten_glFlush=_glFlush;/** @suppress {duplicate } */var _glFramebufferRenderbuffer=(target,attachment,renderbuffertarget,renderbuffer)=>{GLctx.framebufferRenderbuffer(target,attachment,renderbuffertarget,GL.renderbuffers[renderbuffer])};var _emscripten_glFramebufferRenderbuffer=_glFramebufferRenderbuffer;/** @suppress {duplicate } */var _glFramebufferTexture2D=(target,attachment,textarget,texture,level)=>{GLctx.framebufferTexture2D(target,attachment,textarget,GL.textures[texture],level)};var _emscripten_glFramebufferTexture2D=_glFramebufferTexture2D;/** @suppress {duplicate } */var _glFrontFace=x0=>GLctx.frontFace(x0);var _emscripten_glFrontFace=_glFrontFace;/** @suppress {duplicate } */var _glGenBuffers=(n,buffers)=>{GL.genObject(n,buffers,"createBuffer",GL.buffers)};var _emscripten_glGenBuffers=_glGenBuffers;/** @suppress {duplicate } */var _glGenFramebuffers=(n,ids)=>{GL.genObject(n,ids,"createFramebuffer",GL.framebuffers)};var _emscripten_glGenFramebuffers=_glGenFramebuffers;/** @suppress {duplicate } */var _glGenQueriesEXT=(n,ids)=>{for(var i=0;i<n;i++){var query=GLctx.disjointTimerQueryExt["createQueryEXT"]();if(!query){GL.recordError(1282);/* GL_INVALID_OPERATION */while(i<n)HEAP32[(((ids)+(i++*4))>>2)]=0;return}var id=GL.getNewId(GL.queries);query.name=id;GL.queries[id]=query;HEAP32[(((ids)+(i*4))>>2)]=id}};var _emscripten_glGenQueriesEXT=_glGenQueriesEXT;/** @suppress {duplicate } */var _glGenRenderbuffers=(n,renderbuffers)=>{GL.genObject(n,renderbuffers,"createRenderbuffer",GL.renderbuffers)};var _emscripten_glGenRenderbuffers=_glGenRenderbuffers;/** @suppress {duplicate } */var _glGenTextures=(n,textures)=>{GL.genObject(n,textures,"createTexture",GL.textures)};var _emscripten_glGenTextures=_glGenTextures;/** @suppress {duplicate } */var _glGenVertexArrays=(n,arrays)=>{GL.genObject(n,arrays,"createVertexArray",GL.vaos)};/** @suppress {duplicate } */var _glGenVertexArraysOES=_glGenVertexArrays;var _emscripten_glGenVertexArraysOES=_glGenVertexArraysOES;/** @suppress {duplicate } */var _glGenerateMipmap=x0=>GLctx.generateMipmap(x0);var _emscripten_glGenerateMipmap=_glGenerateMipmap;var __glGetActiveAttribOrUniform=(funcName,program,index,bufSize,length,size,type,name)=>{program=GL.programs[program];var info=GLctx[funcName](program,index);if(info){// If an error occurs, nothing will be written to length, size and type and name.
var numBytesWrittenExclNull=name&&stringToUTF8(info.name,name,bufSize);if(length)HEAP32[((length)>>2)]=numBytesWrittenExclNull;if(size)HEAP32[((size)>>2)]=info.size;if(type)HEAP32[((type)>>2)]=info.type}};/** @suppress {duplicate } */var _glGetActiveAttrib=(program,index,bufSize,length,size,type,name)=>{__glGetActiveAttribOrUniform("getActiveAttrib",program,index,bufSize,length,size,type,name)};var _emscripten_glGetActiveAttrib=_glGetActiveAttrib;/** @suppress {duplicate } */var _glGetActiveUniform=(program,index,bufSize,length,size,type,name)=>{__glGetActiveAttribOrUniform("getActiveUniform",program,index,bufSize,length,size,type,name)};var _emscripten_glGetActiveUniform=_glGetActiveUniform;/** @suppress {duplicate } */var _glGetAttachedShaders=(program,maxCount,count,shaders)=>{var result=GLctx.getAttachedShaders(GL.programs[program]);var len=result.length;if(len>maxCount){len=maxCount}HEAP32[((count)>>2)]=len;for(var i=0;i<len;++i){var id=GL.shaders.indexOf(result[i]);HEAP32[(((shaders)+(i*4))>>2)]=id}};var _emscripten_glGetAttachedShaders=_glGetAttachedShaders;/** @suppress {duplicate } */var _glGetAttribLocation=(program,name)=>GLctx.getAttribLocation(GL.programs[program],UTF8ToString(name));var _emscripten_glGetAttribLocation=_glGetAttribLocation;var writeI53ToI64=(ptr,num)=>{HEAPU32[((ptr)>>2)]=num;var lower=HEAPU32[((ptr)>>2)];HEAPU32[(((ptr)+(4))>>2)]=(num-lower)/4294967296};var emscriptenWebGLGet=(name_,p,type)=>{// Guard against user passing a null pointer.
// Note that GLES2 spec does not say anything about how passing a null
// pointer should be treated.  Testing on desktop core GL 3, the application
// crashes on glGetIntegerv to a null pointer, but better to report an error
// instead of doing anything random.
if(!p){GL.recordError(1281);/* GL_INVALID_VALUE */return}var ret=undefined;switch(name_){// Handle a few trivial GLES values
case 36346:// GL_SHADER_COMPILER
ret=1;break;case 36344:// GL_SHADER_BINARY_FORMATS
if(type!=0&&type!=1){GL.recordError(1280)}// Do not write anything to the out pointer, since no binary formats are
// supported.
return;case 36345:// GL_NUM_SHADER_BINARY_FORMATS
ret=0;break;case 34466:// GL_NUM_COMPRESSED_TEXTURE_FORMATS
// WebGL doesn't have GL_NUM_COMPRESSED_TEXTURE_FORMATS (it's obsolete
// since GL_COMPRESSED_TEXTURE_FORMATS returns a JS array that can be
// queried for length), so implement it ourselves to allow C++ GLES2
// code get the length.
var formats=GLctx.getParameter(34467);/*GL_COMPRESSED_TEXTURE_FORMATS*/ret=formats?formats.length:0;break}if(ret===undefined){var result=GLctx.getParameter(name_);switch(typeof result){case"number":ret=result;break;case"boolean":ret=result?1:0;break;case"string":GL.recordError(1280);// GL_INVALID_ENUM
return;case"object":if(result===null){// null is a valid result for some (e.g., which buffer is bound -
// perhaps nothing is bound), but otherwise can mean an invalid
// name_, which we need to report as an error
switch(name_){case 34964:// ARRAY_BUFFER_BINDING
case 35725:// CURRENT_PROGRAM
case 34965:// ELEMENT_ARRAY_BUFFER_BINDING
case 36006:// FRAMEBUFFER_BINDING or DRAW_FRAMEBUFFER_BINDING
case 36007:// RENDERBUFFER_BINDING
case 32873:// TEXTURE_BINDING_2D
case 34229:// WebGL 2 GL_VERTEX_ARRAY_BINDING, or WebGL 1 extension OES_vertex_array_object GL_VERTEX_ARRAY_BINDING_OES
case 34068:{// TEXTURE_BINDING_CUBE_MAP
ret=0;break}default:{GL.recordError(1280);// GL_INVALID_ENUM
return}}}else if(result instanceof Float32Array||result instanceof Uint32Array||result instanceof Int32Array||result instanceof Array){for(var i=0;i<result.length;++i){switch(type){case 0:HEAP32[(((p)+(i*4))>>2)]=result[i];break;case 2:HEAPF32[(((p)+(i*4))>>2)]=result[i];break;case 4:HEAP8[(p)+(i)]=result[i]?1:0;break}}return}else{try{ret=result.name|0}catch(e){GL.recordError(1280);// GL_INVALID_ENUM
err(`GL_INVALID_ENUM in glGet${type}v: Unknown object returned from WebGL getParameter(${name_})! (error: ${e})`);return}}break;default:GL.recordError(1280);// GL_INVALID_ENUM
err(`GL_INVALID_ENUM in glGet${type}v: Native code calling glGet${type}v(${name_}) and it returns ${result} of type ${typeof(result)}!`);return}}switch(type){case 1:writeI53ToI64(p,ret);break;case 0:HEAP32[((p)>>2)]=ret;break;case 2:HEAPF32[((p)>>2)]=ret;break;case 4:HEAP8[p]=ret?1:0;break}};/** @suppress {duplicate } */var _glGetBooleanv=(name_,p)=>emscriptenWebGLGet(name_,p,4);var _emscripten_glGetBooleanv=_glGetBooleanv;/** @suppress {duplicate } */var _glGetBufferParameteriv=(target,value,data)=>{if(!data){// GLES2 specification does not specify how to behave if data is a null
// pointer. Since calling this function does not make sense if data ==
// null, issue a GL error to notify user about it.
GL.recordError(1281);/* GL_INVALID_VALUE */return}HEAP32[((data)>>2)]=GLctx.getBufferParameter(target,value)};var _emscripten_glGetBufferParameteriv=_glGetBufferParameteriv;/** @suppress {duplicate } */var _glGetError=()=>{var error=GLctx.getError()||GL.lastError;GL.lastError=0;/*GL_NO_ERROR*/return error};var _emscripten_glGetError=_glGetError;/** @suppress {duplicate } */var _glGetFloatv=(name_,p)=>emscriptenWebGLGet(name_,p,2);var _emscripten_glGetFloatv=_glGetFloatv;/** @suppress {duplicate } */var _glGetFramebufferAttachmentParameteriv=(target,attachment,pname,params)=>{var result=GLctx.getFramebufferAttachmentParameter(target,attachment,pname);if(result instanceof WebGLRenderbuffer||result instanceof WebGLTexture){result=result.name|0}HEAP32[((params)>>2)]=result};var _emscripten_glGetFramebufferAttachmentParameteriv=_glGetFramebufferAttachmentParameteriv;/** @suppress {duplicate } */var _glGetIntegerv=(name_,p)=>emscriptenWebGLGet(name_,p,0);var _emscripten_glGetIntegerv=_glGetIntegerv;/** @suppress {duplicate } */var _glGetProgramInfoLog=(program,maxLength,length,infoLog)=>{var log=GLctx.getProgramInfoLog(GL.programs[program]);if(log===null)log="(unknown error)";var numBytesWrittenExclNull=(maxLength>0&&infoLog)?stringToUTF8(log,infoLog,maxLength):0;if(length)HEAP32[((length)>>2)]=numBytesWrittenExclNull};var _emscripten_glGetProgramInfoLog=_glGetProgramInfoLog;/** @suppress {duplicate } */var _glGetProgramiv=(program,pname,p)=>{if(!p){// GLES2 specification does not specify how to behave if p is a null
// pointer. Since calling this function does not make sense if p == null,
// issue a GL error to notify user about it.
GL.recordError(1281);/* GL_INVALID_VALUE */return}if(program>=GL.counter){GL.recordError(1281);/* GL_INVALID_VALUE */return}program=GL.programs[program];if(pname==35716){// GL_INFO_LOG_LENGTH
var log=GLctx.getProgramInfoLog(program);if(log===null)log="(unknown error)";HEAP32[((p)>>2)]=log.length+1}else if(pname==35719)/* GL_ACTIVE_UNIFORM_MAX_LENGTH */{if(!program.maxUniformLength){var numActiveUniforms=GLctx.getProgramParameter(program,35718);/*GL_ACTIVE_UNIFORMS*/for(var i=0;i<numActiveUniforms;++i){program.maxUniformLength=Math.max(program.maxUniformLength,GLctx.getActiveUniform(program,i).name.length+1)}}HEAP32[((p)>>2)]=program.maxUniformLength}else if(pname==35722)/* GL_ACTIVE_ATTRIBUTE_MAX_LENGTH */{if(!program.maxAttributeLength){var numActiveAttributes=GLctx.getProgramParameter(program,35721);/*GL_ACTIVE_ATTRIBUTES*/for(var i=0;i<numActiveAttributes;++i){program.maxAttributeLength=Math.max(program.maxAttributeLength,GLctx.getActiveAttrib(program,i).name.length+1)}}HEAP32[((p)>>2)]=program.maxAttributeLength}else if(pname==35381)/* GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH */{if(!program.maxUniformBlockNameLength){var numActiveUniformBlocks=GLctx.getProgramParameter(program,35382);/*GL_ACTIVE_UNIFORM_BLOCKS*/for(var i=0;i<numActiveUniformBlocks;++i){program.maxUniformBlockNameLength=Math.max(program.maxUniformBlockNameLength,GLctx.getActiveUniformBlockName(program,i).length+1)}}HEAP32[((p)>>2)]=program.maxUniformBlockNameLength}else{HEAP32[((p)>>2)]=GLctx.getProgramParameter(program,pname)}};var _emscripten_glGetProgramiv=_glGetProgramiv;/** @suppress {duplicate } */var _glGetQueryObjecti64vEXT=(id,pname,params)=>{if(!params){// GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
// if p == null, issue a GL error to notify user about it.
GL.recordError(1281);/* GL_INVALID_VALUE */return}var query=GL.queries[id];var param;{param=GLctx.disjointTimerQueryExt["getQueryObjectEXT"](query,pname)}var ret;if(typeof param=="boolean"){ret=param?1:0}else{ret=param}writeI53ToI64(params,ret)};var _emscripten_glGetQueryObjecti64vEXT=_glGetQueryObjecti64vEXT;/** @suppress {duplicate } */var _glGetQueryObjectivEXT=(id,pname,params)=>{if(!params){// GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
// if p == null, issue a GL error to notify user about it.
GL.recordError(1281);/* GL_INVALID_VALUE */return}var query=GL.queries[id];var param=GLctx.disjointTimerQueryExt["getQueryObjectEXT"](query,pname);var ret;if(typeof param=="boolean"){ret=param?1:0}else{ret=param}HEAP32[((params)>>2)]=ret};var _emscripten_glGetQueryObjectivEXT=_glGetQueryObjectivEXT;/** @suppress {duplicate } */var _glGetQueryObjectui64vEXT=_glGetQueryObjecti64vEXT;var _emscripten_glGetQueryObjectui64vEXT=_glGetQueryObjectui64vEXT;/** @suppress {duplicate } */var _glGetQueryObjectuivEXT=_glGetQueryObjectivEXT;var _emscripten_glGetQueryObjectuivEXT=_glGetQueryObjectuivEXT;/** @suppress {duplicate } */var _glGetQueryivEXT=(target,pname,params)=>{if(!params){// GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
// if p == null, issue a GL error to notify user about it.
GL.recordError(1281);/* GL_INVALID_VALUE */return}HEAP32[((params)>>2)]=GLctx.disjointTimerQueryExt["getQueryEXT"](target,pname)};var _emscripten_glGetQueryivEXT=_glGetQueryivEXT;/** @suppress {duplicate } */var _glGetRenderbufferParameteriv=(target,pname,params)=>{if(!params){// GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
// if params == null, issue a GL error to notify user about it.
GL.recordError(1281);/* GL_INVALID_VALUE */return}HEAP32[((params)>>2)]=GLctx.getRenderbufferParameter(target,pname)};var _emscripten_glGetRenderbufferParameteriv=_glGetRenderbufferParameteriv;/** @suppress {duplicate } */var _glGetShaderInfoLog=(shader,maxLength,length,infoLog)=>{var log=GLctx.getShaderInfoLog(GL.shaders[shader]);if(log===null)log="(unknown error)";var numBytesWrittenExclNull=(maxLength>0&&infoLog)?stringToUTF8(log,infoLog,maxLength):0;if(length)HEAP32[((length)>>2)]=numBytesWrittenExclNull};var _emscripten_glGetShaderInfoLog=_glGetShaderInfoLog;/** @suppress {duplicate } */var _glGetShaderPrecisionFormat=(shaderType,precisionType,range,precision)=>{var result=GLctx.getShaderPrecisionFormat(shaderType,precisionType);HEAP32[((range)>>2)]=result.rangeMin;HEAP32[(((range)+(4))>>2)]=result.rangeMax;HEAP32[((precision)>>2)]=result.precision};var _emscripten_glGetShaderPrecisionFormat=_glGetShaderPrecisionFormat;/** @suppress {duplicate } */var _glGetShaderSource=(shader,bufSize,length,source)=>{var result=GLctx.getShaderSource(GL.shaders[shader]);if(!result)return;// If an error occurs, nothing will be written to length or source.
var numBytesWrittenExclNull=(bufSize>0&&source)?stringToUTF8(result,source,bufSize):0;if(length)HEAP32[((length)>>2)]=numBytesWrittenExclNull};var _emscripten_glGetShaderSource=_glGetShaderSource;/** @suppress {duplicate } */var _glGetShaderiv=(shader,pname,p)=>{if(!p){// GLES2 specification does not specify how to behave if p is a null
// pointer. Since calling this function does not make sense if p == null,
// issue a GL error to notify user about it.
GL.recordError(1281);/* GL_INVALID_VALUE */return}if(pname==35716){// GL_INFO_LOG_LENGTH
var log=GLctx.getShaderInfoLog(GL.shaders[shader]);if(log===null)log="(unknown error)";// The GLES2 specification says that if the shader has an empty info log,
// a value of 0 is returned. Otherwise the log has a null char appended.
// (An empty string is falsey, so we can just check that instead of
// looking at log.length.)
var logLength=log?log.length+1:0;HEAP32[((p)>>2)]=logLength}else if(pname==35720){// GL_SHADER_SOURCE_LENGTH
var source=GLctx.getShaderSource(GL.shaders[shader]);// source may be a null, or the empty string, both of which are falsey
// values that we report a 0 length for.
var sourceLength=source?source.length+1:0;HEAP32[((p)>>2)]=sourceLength}else{HEAP32[((p)>>2)]=GLctx.getShaderParameter(GL.shaders[shader],pname)}};var _emscripten_glGetShaderiv=_glGetShaderiv;var webglGetExtensions=function $webglGetExtensions(){var exts=getEmscriptenSupportedExtensions(GLctx);exts=exts.concat(exts.map(e=>"GL_"+e));return exts};/** @suppress {duplicate } */var _glGetString=name_=>{var ret=GL.stringCache[name_];if(!ret){switch(name_){case 7939:/* GL_EXTENSIONS */ret=stringToNewUTF8(webglGetExtensions().join(" "));break;case 7936:/* GL_VENDOR */case 7937:/* GL_RENDERER */case 37445:/* UNMASKED_VENDOR_WEBGL */case 37446:/* UNMASKED_RENDERER_WEBGL */var s=GLctx.getParameter(name_);if(!s){GL.recordError(1280)}ret=s?stringToNewUTF8(s):0;break;case 7938:/* GL_VERSION */var webGLVersion=GLctx.getParameter(7938);// return GLES version string corresponding to the version of the WebGL context
var glVersion=`OpenGL ES 2.0 (${webGLVersion})`;ret=stringToNewUTF8(glVersion);break;case 35724:/* GL_SHADING_LANGUAGE_VERSION */var glslVersion=GLctx.getParameter(35724);// extract the version number 'N.M' from the string 'WebGL GLSL ES N.M ...'
var ver_re=/^WebGL GLSL ES ([0-9]\.[0-9][0-9]?)(?:$| .*)/;var ver_num=glslVersion.match(ver_re);if(ver_num!==null){if(ver_num[1].length==3)ver_num[1]=ver_num[1]+"0";// ensure minor version has 2 digits
glslVersion=`OpenGL ES GLSL ES ${ver_num[1]} (${glslVersion})`}ret=stringToNewUTF8(glslVersion);break;default:GL.recordError(1280)}// fall through
GL.stringCache[name_]=ret}return ret};var _emscripten_glGetString=_glGetString;/** @suppress {duplicate } */var _glGetTexParameterfv=(target,pname,params)=>{if(!params){// GLES2 specification does not specify how to behave if params is a null
// pointer. Since calling this function does not make sense if p == null,
// issue a GL error to notify user about it.
GL.recordError(1281);/* GL_INVALID_VALUE */return}HEAPF32[((params)>>2)]=GLctx.getTexParameter(target,pname)};var _emscripten_glGetTexParameterfv=_glGetTexParameterfv;/** @suppress {duplicate } */var _glGetTexParameteriv=(target,pname,params)=>{if(!params){// GLES2 specification does not specify how to behave if params is a null
// pointer. Since calling this function does not make sense if p == null,
// issue a GL error to notify user about it.
GL.recordError(1281);/* GL_INVALID_VALUE */return}HEAP32[((params)>>2)]=GLctx.getTexParameter(target,pname)};var _emscripten_glGetTexParameteriv=_glGetTexParameteriv;/** @suppress {checkTypes} */var jstoi_q=str=>parseInt(str);/** @noinline */var webglGetLeftBracePos=name=>name.slice(-1)=="]"&&name.lastIndexOf("[");var webglPrepareUniformLocationsBeforeFirstUse=program=>{var uniformLocsById=program.uniformLocsById,// Maps GLuint -> WebGLUniformLocation
uniformSizeAndIdsByName=program.uniformSizeAndIdsByName,// Maps name -> [uniform array length, GLuint]
i,j;// On the first time invocation of glGetUniformLocation on this shader program:
// initialize cache data structures and discover which uniforms are arrays.
if(!uniformLocsById){// maps GLint integer locations to WebGLUniformLocations
program.uniformLocsById=uniformLocsById={};// maps integer locations back to uniform name strings, so that we can lazily fetch uniform array locations
program.uniformArrayNamesById={};var numActiveUniforms=GLctx.getProgramParameter(program,35718);/*GL_ACTIVE_UNIFORMS*/for(i=0;i<numActiveUniforms;++i){var u=GLctx.getActiveUniform(program,i);var nm=u.name;var sz=u.size;var lb=webglGetLeftBracePos(nm);var arrayName=lb>0?nm.slice(0,lb):nm;// Assign a new location.
var id=program.uniformIdCounter;program.uniformIdCounter+=sz;// Eagerly get the location of the uniformArray[0] base element.
// The remaining indices >0 will be left for lazy evaluation to
// improve performance. Those may never be needed to fetch, if the
// application fills arrays always in full starting from the first
// element of the array.
uniformSizeAndIdsByName[arrayName]=[sz,id];// Store placeholder integers in place that highlight that these
// >0 index locations are array indices pending population.
for(j=0;j<sz;++j){uniformLocsById[id]=j;program.uniformArrayNamesById[id++]=arrayName}}}};/** @suppress {duplicate } */var _glGetUniformLocation=(program,name)=>{name=UTF8ToString(name);if(program=GL.programs[program]){webglPrepareUniformLocationsBeforeFirstUse(program);var uniformLocsById=program.uniformLocsById;// Maps GLuint -> WebGLUniformLocation
var arrayIndex=0;var uniformBaseName=name;// Invariant: when populating integer IDs for uniform locations, we must
// maintain the precondition that arrays reside in contiguous addresses,
// i.e. for a 'vec4 colors[10];', colors[4] must be at location
// colors[0]+4.  However, user might call glGetUniformLocation(program,
// "colors") for an array, so we cannot discover based on the user input
// arguments whether the uniform we are dealing with is an array. The only
// way to discover which uniforms are arrays is to enumerate over all the
// active uniforms in the program.
var leftBrace=webglGetLeftBracePos(name);// If user passed an array accessor "[index]", parse the array index off the accessor.
if(leftBrace>0){arrayIndex=jstoi_q(name.slice(leftBrace+1))>>>0;// "index]", coerce parseInt(']') with >>>0 to treat "foo[]" as "foo[0]" and foo[-1] as unsigned out-of-bounds.
uniformBaseName=name.slice(0,leftBrace)}// Have we cached the location of this uniform before?
// A pair [array length, GLint of the uniform location]
var sizeAndId=program.uniformSizeAndIdsByName[uniformBaseName];// If an uniform with this name exists, and if its index is within the
// array limits (if it's even an array), query the WebGLlocation, or
// return an existing cached location.
if(sizeAndId&&arrayIndex<sizeAndId[0]){arrayIndex+=sizeAndId[1];// Add the base location of the uniform to the array index offset.
if((uniformLocsById[arrayIndex]=uniformLocsById[arrayIndex]||GLctx.getUniformLocation(program,name))){return arrayIndex}}}else{// N.b. we are currently unable to distinguish between GL program IDs that
// never existed vs GL program IDs that have been deleted, so report
// GL_INVALID_VALUE in both cases.
GL.recordError(1281)}/* GL_INVALID_VALUE */return-1};var _emscripten_glGetUniformLocation=_glGetUniformLocation;var webglGetUniformLocation=location=>{var p=GLctx.currentProgram;if(p){var webglLoc=p.uniformLocsById[location];// p.uniformLocsById[location] stores either an integer, or a
// WebGLUniformLocation.
// If an integer, we have not yet bound the location, so do it now. The
// integer value specifies the array index we should bind to.
if(typeof webglLoc=="number"){p.uniformLocsById[location]=webglLoc=GLctx.getUniformLocation(p,p.uniformArrayNamesById[location]+(webglLoc>0?`[${webglLoc}]`:""))}// Else an already cached WebGLUniformLocation, return it.
return webglLoc}else{GL.recordError(1282)}};/** @suppress{checkTypes} */var emscriptenWebGLGetUniform=(program,location,params,type)=>{if(!params){// GLES2 specification does not specify how to behave if params is a null
// pointer. Since calling this function does not make sense if params ==
// null, issue a GL error to notify user about it.
GL.recordError(1281);/* GL_INVALID_VALUE */return}program=GL.programs[program];webglPrepareUniformLocationsBeforeFirstUse(program);var data=GLctx.getUniform(program,webglGetUniformLocation(location));if(typeof data=="number"||typeof data=="boolean"){switch(type){case 0:HEAP32[((params)>>2)]=data;break;case 2:HEAPF32[((params)>>2)]=data;break}}else{for(var i=0;i<data.length;i++){switch(type){case 0:HEAP32[(((params)+(i*4))>>2)]=data[i];break;case 2:HEAPF32[(((params)+(i*4))>>2)]=data[i];break}}}};/** @suppress {duplicate } */var _glGetUniformfv=(program,location,params)=>{emscriptenWebGLGetUniform(program,location,params,2)};var _emscripten_glGetUniformfv=_glGetUniformfv;/** @suppress {duplicate } */var _glGetUniformiv=(program,location,params)=>{emscriptenWebGLGetUniform(program,location,params,0)};var _emscripten_glGetUniformiv=_glGetUniformiv;/** @suppress {duplicate } */var _glGetVertexAttribPointerv=(index,pname,pointer)=>{if(!pointer){// GLES2 specification does not specify how to behave if pointer is a null
// pointer. Since calling this function does not make sense if pointer ==
// null, issue a GL error to notify user about it.
GL.recordError(1281);/* GL_INVALID_VALUE */return}HEAP32[((pointer)>>2)]=GLctx.getVertexAttribOffset(index,pname)};var _emscripten_glGetVertexAttribPointerv=_glGetVertexAttribPointerv;/** @suppress{checkTypes} */var emscriptenWebGLGetVertexAttrib=(index,pname,params,type)=>{if(!params){// GLES2 specification does not specify how to behave if params is a null
// pointer. Since calling this function does not make sense if params ==
// null, issue a GL error to notify user about it.
GL.recordError(1281);/* GL_INVALID_VALUE */return}var data=GLctx.getVertexAttrib(index,pname);if(pname==34975)/*VERTEX_ATTRIB_ARRAY_BUFFER_BINDING*/{HEAP32[((params)>>2)]=data&&data["name"]}else if(typeof data=="number"||typeof data=="boolean"){switch(type){case 0:HEAP32[((params)>>2)]=data;break;case 2:HEAPF32[((params)>>2)]=data;break;case 5:HEAP32[((params)>>2)]=Math.fround(data);break}}else{for(var i=0;i<data.length;i++){switch(type){case 0:HEAP32[(((params)+(i*4))>>2)]=data[i];break;case 2:HEAPF32[(((params)+(i*4))>>2)]=data[i];break;case 5:HEAP32[(((params)+(i*4))>>2)]=Math.fround(data[i]);break}}}};/** @suppress {duplicate } */var _glGetVertexAttribfv=(index,pname,params)=>{// N.B. This function may only be called if the vertex attribute was
// specified using the function glVertexAttrib*f(), otherwise the results
// are undefined. (GLES3 spec 6.1.12)
emscriptenWebGLGetVertexAttrib(index,pname,params,2)};var _emscripten_glGetVertexAttribfv=_glGetVertexAttribfv;/** @suppress {duplicate } */var _glGetVertexAttribiv=(index,pname,params)=>{// N.B. This function may only be called if the vertex attribute was
// specified using the function glVertexAttrib*f(), otherwise the results
// are undefined. (GLES3 spec 6.1.12)
emscriptenWebGLGetVertexAttrib(index,pname,params,5)};var _emscripten_glGetVertexAttribiv=_glGetVertexAttribiv;/** @suppress {duplicate } */var _glHint=(x0,x1)=>GLctx.hint(x0,x1);var _emscripten_glHint=_glHint;/** @suppress {duplicate } */var _glIsBuffer=buffer=>{var b=GL.buffers[buffer];if(!b)return 0;return GLctx.isBuffer(b)};var _emscripten_glIsBuffer=_glIsBuffer;/** @suppress {duplicate } */var _glIsEnabled=x0=>GLctx.isEnabled(x0);var _emscripten_glIsEnabled=_glIsEnabled;/** @suppress {duplicate } */var _glIsFramebuffer=framebuffer=>{var fb=GL.framebuffers[framebuffer];if(!fb)return 0;return GLctx.isFramebuffer(fb)};var _emscripten_glIsFramebuffer=_glIsFramebuffer;/** @suppress {duplicate } */var _glIsProgram=program=>{program=GL.programs[program];if(!program)return 0;return GLctx.isProgram(program)};var _emscripten_glIsProgram=_glIsProgram;/** @suppress {duplicate } */var _glIsQueryEXT=id=>{var query=GL.queries[id];if(!query)return 0;return GLctx.disjointTimerQueryExt["isQueryEXT"](query)};var _emscripten_glIsQueryEXT=_glIsQueryEXT;/** @suppress {duplicate } */var _glIsRenderbuffer=renderbuffer=>{var rb=GL.renderbuffers[renderbuffer];if(!rb)return 0;return GLctx.isRenderbuffer(rb)};var _emscripten_glIsRenderbuffer=_glIsRenderbuffer;/** @suppress {duplicate } */var _glIsShader=shader=>{var s=GL.shaders[shader];if(!s)return 0;return GLctx.isShader(s)};var _emscripten_glIsShader=_glIsShader;/** @suppress {duplicate } */var _glIsTexture=id=>{var texture=GL.textures[id];if(!texture)return 0;return GLctx.isTexture(texture)};var _emscripten_glIsTexture=_glIsTexture;/** @suppress {duplicate } */var _glIsVertexArray=array=>{var vao=GL.vaos[array];if(!vao)return 0;return GLctx.isVertexArray(vao)};/** @suppress {duplicate } */var _glIsVertexArrayOES=_glIsVertexArray;var _emscripten_glIsVertexArrayOES=_glIsVertexArrayOES;/** @suppress {duplicate } */var _glLineWidth=x0=>GLctx.lineWidth(x0);var _emscripten_glLineWidth=_glLineWidth;/** @suppress {duplicate } */var _glLinkProgram=program=>{program=GL.programs[program];GLctx.linkProgram(program);// Invalidate earlier computed uniform->ID mappings, those have now become stale
program.uniformLocsById=0;// Mark as null-like so that glGetUniformLocation() knows to populate this again.
program.uniformSizeAndIdsByName={}};var _emscripten_glLinkProgram=_glLinkProgram;/** @suppress {duplicate } */var _glPixelStorei=(pname,param)=>{if(pname==3317){GL.unpackAlignment=param}else if(pname==3314){GL.unpackRowLength=param}GLctx.pixelStorei(pname,param)};var _emscripten_glPixelStorei=_glPixelStorei;/** @suppress {duplicate } */var _glPolygonModeWEBGL=(face,mode)=>{GLctx.webglPolygonMode["polygonModeWEBGL"](face,mode)};var _emscripten_glPolygonModeWEBGL=_glPolygonModeWEBGL;/** @suppress {duplicate } */var _glPolygonOffset=(x0,x1)=>GLctx.polygonOffset(x0,x1);var _emscripten_glPolygonOffset=_glPolygonOffset;/** @suppress {duplicate } */var _glPolygonOffsetClampEXT=(factor,units,clamp)=>{GLctx.extPolygonOffsetClamp["polygonOffsetClampEXT"](factor,units,clamp)};var _emscripten_glPolygonOffsetClampEXT=_glPolygonOffsetClampEXT;/** @suppress {duplicate } */var _glQueryCounterEXT=(id,target)=>{GLctx.disjointTimerQueryExt["queryCounterEXT"](GL.queries[id],target)};var _emscripten_glQueryCounterEXT=_glQueryCounterEXT;var computeUnpackAlignedImageSize=(width,height,sizePerPixel)=>{function roundedToNextMultipleOf(x,y){return(x+y-1)&-y}var plainRowSize=(GL.unpackRowLength||width)*sizePerPixel;var alignedRowSize=roundedToNextMultipleOf(plainRowSize,GL.unpackAlignment);return height*alignedRowSize};var colorChannelsInGlTextureFormat=format=>{// Micro-optimizations for size: map format to size by subtracting smallest
// enum value (0x1902) from all values first.  Also omit the most common
// size value (1) from the list, which is assumed by formats not on the
// list.
var colorChannels={// 0x1902 /* GL_DEPTH_COMPONENT */ - 0x1902: 1,
// 0x1906 /* GL_ALPHA */ - 0x1902: 1,
5:3,6:4,// 0x1909 /* GL_LUMINANCE */ - 0x1902: 1,
8:2,29502:3,29504:4};return colorChannels[format-6402]||1};var heapObjectForWebGLType=type=>{// Micro-optimization for size: Subtract lowest GL enum number (0x1400/* GL_BYTE */) from type to compare
// smaller values for the heap, for shorter generated code size.
// Also the type HEAPU16 is not tested for explicitly, but any unrecognized type will return out HEAPU16.
// (since most types are HEAPU16)
type-=5120;if(type==1)return HEAPU8;if(type==4)return HEAP32;if(type==6)return HEAPF32;if(type==5||type==28922)return HEAPU32;return HEAPU16};var toTypedArrayIndex=(pointer,heap)=>pointer>>>(31-Math.clz32(heap.BYTES_PER_ELEMENT));var emscriptenWebGLGetTexPixelData=(type,format,width,height,pixels,internalFormat)=>{var heap=heapObjectForWebGLType(type);var sizePerPixel=colorChannelsInGlTextureFormat(format)*heap.BYTES_PER_ELEMENT;var bytes=computeUnpackAlignedImageSize(width,height,sizePerPixel);return heap.subarray(toTypedArrayIndex(pixels,heap),toTypedArrayIndex(pixels+bytes,heap))};/** @suppress {duplicate } */var _glReadPixels=(x,y,width,height,format,type,pixels)=>{var pixelData=emscriptenWebGLGetTexPixelData(type,format,width,height,pixels,format);if(!pixelData){GL.recordError(1280);/*GL_INVALID_ENUM*/return}GLctx.readPixels(x,y,width,height,format,type,pixelData)};var _emscripten_glReadPixels=_glReadPixels;/** @suppress {duplicate } */var _glReleaseShaderCompiler=()=>{};// NOP (as allowed by GLES 2.0 spec)
var _emscripten_glReleaseShaderCompiler=_glReleaseShaderCompiler;/** @suppress {duplicate } */var _glRenderbufferStorage=(x0,x1,x2,x3)=>GLctx.renderbufferStorage(x0,x1,x2,x3);var _emscripten_glRenderbufferStorage=_glRenderbufferStorage;/** @suppress {duplicate } */var _glSampleCoverage=(value,invert)=>{GLctx.sampleCoverage(value,!!invert)};var _emscripten_glSampleCoverage=_glSampleCoverage;/** @suppress {duplicate } */var _glScissor=(x0,x1,x2,x3)=>GLctx.scissor(x0,x1,x2,x3);var _emscripten_glScissor=_glScissor;/** @suppress {duplicate } */var _glShaderBinary=(count,shaders,binaryformat,binary,length)=>{GL.recordError(1280)};/*GL_INVALID_ENUM*/var _emscripten_glShaderBinary=_glShaderBinary;/** @suppress {duplicate } */var _glShaderSource=(shader,count,string,length)=>{var source=GL.getSource(shader,count,string,length);GLctx.shaderSource(GL.shaders[shader],source)};var _emscripten_glShaderSource=_glShaderSource;/** @suppress {duplicate } */var _glStencilFunc=(x0,x1,x2)=>GLctx.stencilFunc(x0,x1,x2);var _emscripten_glStencilFunc=_glStencilFunc;/** @suppress {duplicate } */var _glStencilFuncSeparate=(x0,x1,x2,x3)=>GLctx.stencilFuncSeparate(x0,x1,x2,x3);var _emscripten_glStencilFuncSeparate=_glStencilFuncSeparate;/** @suppress {duplicate } */var _glStencilMask=x0=>GLctx.stencilMask(x0);var _emscripten_glStencilMask=_glStencilMask;/** @suppress {duplicate } */var _glStencilMaskSeparate=(x0,x1)=>GLctx.stencilMaskSeparate(x0,x1);var _emscripten_glStencilMaskSeparate=_glStencilMaskSeparate;/** @suppress {duplicate } */var _glStencilOp=(x0,x1,x2)=>GLctx.stencilOp(x0,x1,x2);var _emscripten_glStencilOp=_glStencilOp;/** @suppress {duplicate } */var _glStencilOpSeparate=(x0,x1,x2,x3)=>GLctx.stencilOpSeparate(x0,x1,x2,x3);var _emscripten_glStencilOpSeparate=_glStencilOpSeparate;/** @suppress {duplicate } */var _glTexImage2D=(target,level,internalFormat,width,height,border,format,type,pixels)=>{var pixelData=pixels?emscriptenWebGLGetTexPixelData(type,format,width,height,pixels,internalFormat):null;GLctx.texImage2D(target,level,internalFormat,width,height,border,format,type,pixelData)};var _emscripten_glTexImage2D=_glTexImage2D;/** @suppress {duplicate } */var _glTexParameterf=(x0,x1,x2)=>GLctx.texParameterf(x0,x1,x2);var _emscripten_glTexParameterf=_glTexParameterf;/** @suppress {duplicate } */var _glTexParameterfv=(target,pname,params)=>{var param=HEAPF32[((params)>>2)];GLctx.texParameterf(target,pname,param)};var _emscripten_glTexParameterfv=_glTexParameterfv;/** @suppress {duplicate } */var _glTexParameteri=(x0,x1,x2)=>GLctx.texParameteri(x0,x1,x2);var _emscripten_glTexParameteri=_glTexParameteri;/** @suppress {duplicate } */var _glTexParameteriv=(target,pname,params)=>{var param=HEAP32[((params)>>2)];GLctx.texParameteri(target,pname,param)};var _emscripten_glTexParameteriv=_glTexParameteriv;/** @suppress {duplicate } */var _glTexSubImage2D=(target,level,xoffset,yoffset,width,height,format,type,pixels)=>{var pixelData=pixels?emscriptenWebGLGetTexPixelData(type,format,width,height,pixels,0):null;GLctx.texSubImage2D(target,level,xoffset,yoffset,width,height,format,type,pixelData)};var _emscripten_glTexSubImage2D=_glTexSubImage2D;/** @suppress {duplicate } */var _glUniform1f=(location,v0)=>{GLctx.uniform1f(webglGetUniformLocation(location),v0)};var _emscripten_glUniform1f=_glUniform1f;var miniTempWebGLFloatBuffers=[];/** @suppress {duplicate } */var _glUniform1fv=(location,count,value)=>{if(count<=288){// avoid allocation when uploading few enough uniforms
var view=miniTempWebGLFloatBuffers[count];for(var i=0;i<count;++i){view[i]=HEAPF32[(((value)+(4*i))>>2)]}}else{var view=HEAPF32.subarray((((value)>>2)),((value+count*4)>>2))}GLctx.uniform1fv(webglGetUniformLocation(location),view)};var _emscripten_glUniform1fv=_glUniform1fv;/** @suppress {duplicate } */var _glUniform1i=(location,v0)=>{GLctx.uniform1i(webglGetUniformLocation(location),v0)};var _emscripten_glUniform1i=_glUniform1i;var miniTempWebGLIntBuffers=[];/** @suppress {duplicate } */var _glUniform1iv=(location,count,value)=>{if(count<=288){// avoid allocation when uploading few enough uniforms
var view=miniTempWebGLIntBuffers[count];for(var i=0;i<count;++i){view[i]=HEAP32[(((value)+(4*i))>>2)]}}else{var view=HEAP32.subarray((((value)>>2)),((value+count*4)>>2))}GLctx.uniform1iv(webglGetUniformLocation(location),view)};var _emscripten_glUniform1iv=_glUniform1iv;/** @suppress {duplicate } */var _glUniform2f=(location,v0,v1)=>{GLctx.uniform2f(webglGetUniformLocation(location),v0,v1)};var _emscripten_glUniform2f=_glUniform2f;/** @suppress {duplicate } */var _glUniform2fv=(location,count,value)=>{if(count<=144){// avoid allocation when uploading few enough uniforms
count*=2;var view=miniTempWebGLFloatBuffers[count];for(var i=0;i<count;i+=2){view[i]=HEAPF32[(((value)+(4*i))>>2)];view[i+1]=HEAPF32[(((value)+(4*i+4))>>2)]}}else{var view=HEAPF32.subarray((((value)>>2)),((value+count*8)>>2))}GLctx.uniform2fv(webglGetUniformLocation(location),view)};var _emscripten_glUniform2fv=_glUniform2fv;/** @suppress {duplicate } */var _glUniform2i=(location,v0,v1)=>{GLctx.uniform2i(webglGetUniformLocation(location),v0,v1)};var _emscripten_glUniform2i=_glUniform2i;/** @suppress {duplicate } */var _glUniform2iv=(location,count,value)=>{if(count<=144){// avoid allocation when uploading few enough uniforms
count*=2;var view=miniTempWebGLIntBuffers[count];for(var i=0;i<count;i+=2){view[i]=HEAP32[(((value)+(4*i))>>2)];view[i+1]=HEAP32[(((value)+(4*i+4))>>2)]}}else{var view=HEAP32.subarray((((value)>>2)),((value+count*8)>>2))}GLctx.uniform2iv(webglGetUniformLocation(location),view)};var _emscripten_glUniform2iv=_glUniform2iv;/** @suppress {duplicate } */var _glUniform3f=(location,v0,v1,v2)=>{GLctx.uniform3f(webglGetUniformLocation(location),v0,v1,v2)};var _emscripten_glUniform3f=_glUniform3f;/** @suppress {duplicate } */var _glUniform3fv=(location,count,value)=>{if(count<=96){// avoid allocation when uploading few enough uniforms
count*=3;var view=miniTempWebGLFloatBuffers[count];for(var i=0;i<count;i+=3){view[i]=HEAPF32[(((value)+(4*i))>>2)];view[i+1]=HEAPF32[(((value)+(4*i+4))>>2)];view[i+2]=HEAPF32[(((value)+(4*i+8))>>2)]}}else{var view=HEAPF32.subarray((((value)>>2)),((value+count*12)>>2))}GLctx.uniform3fv(webglGetUniformLocation(location),view)};var _emscripten_glUniform3fv=_glUniform3fv;/** @suppress {duplicate } */var _glUniform3i=(location,v0,v1,v2)=>{GLctx.uniform3i(webglGetUniformLocation(location),v0,v1,v2)};var _emscripten_glUniform3i=_glUniform3i;/** @suppress {duplicate } */var _glUniform3iv=(location,count,value)=>{if(count<=96){// avoid allocation when uploading few enough uniforms
count*=3;var view=miniTempWebGLIntBuffers[count];for(var i=0;i<count;i+=3){view[i]=HEAP32[(((value)+(4*i))>>2)];view[i+1]=HEAP32[(((value)+(4*i+4))>>2)];view[i+2]=HEAP32[(((value)+(4*i+8))>>2)]}}else{var view=HEAP32.subarray((((value)>>2)),((value+count*12)>>2))}GLctx.uniform3iv(webglGetUniformLocation(location),view)};var _emscripten_glUniform3iv=_glUniform3iv;/** @suppress {duplicate } */var _glUniform4f=(location,v0,v1,v2,v3)=>{GLctx.uniform4f(webglGetUniformLocation(location),v0,v1,v2,v3)};var _emscripten_glUniform4f=_glUniform4f;/** @suppress {duplicate } */var _glUniform4fv=(location,count,value)=>{if(count<=72){// avoid allocation when uploading few enough uniforms
var view=miniTempWebGLFloatBuffers[4*count];// hoist the heap out of the loop for size and for pthreads+growth.
var heap=HEAPF32;value=((value)>>2);count*=4;for(var i=0;i<count;i+=4){var dst=value+i;view[i]=heap[dst];view[i+1]=heap[dst+1];view[i+2]=heap[dst+2];view[i+3]=heap[dst+3]}}else{var view=HEAPF32.subarray((((value)>>2)),((value+count*16)>>2))}GLctx.uniform4fv(webglGetUniformLocation(location),view)};var _emscripten_glUniform4fv=_glUniform4fv;/** @suppress {duplicate } */var _glUniform4i=(location,v0,v1,v2,v3)=>{GLctx.uniform4i(webglGetUniformLocation(location),v0,v1,v2,v3)};var _emscripten_glUniform4i=_glUniform4i;/** @suppress {duplicate } */var _glUniform4iv=(location,count,value)=>{if(count<=72){// avoid allocation when uploading few enough uniforms
count*=4;var view=miniTempWebGLIntBuffers[count];for(var i=0;i<count;i+=4){view[i]=HEAP32[(((value)+(4*i))>>2)];view[i+1]=HEAP32[(((value)+(4*i+4))>>2)];view[i+2]=HEAP32[(((value)+(4*i+8))>>2)];view[i+3]=HEAP32[(((value)+(4*i+12))>>2)]}}else{var view=HEAP32.subarray((((value)>>2)),((value+count*16)>>2))}GLctx.uniform4iv(webglGetUniformLocation(location),view)};var _emscripten_glUniform4iv=_glUniform4iv;/** @suppress {duplicate } */var _glUniformMatrix2fv=(location,count,transpose,value)=>{if(count<=72){// avoid allocation when uploading few enough uniforms
count*=4;var view=miniTempWebGLFloatBuffers[count];for(var i=0;i<count;i+=4){view[i]=HEAPF32[(((value)+(4*i))>>2)];view[i+1]=HEAPF32[(((value)+(4*i+4))>>2)];view[i+2]=HEAPF32[(((value)+(4*i+8))>>2)];view[i+3]=HEAPF32[(((value)+(4*i+12))>>2)]}}else{var view=HEAPF32.subarray((((value)>>2)),((value+count*16)>>2))}GLctx.uniformMatrix2fv(webglGetUniformLocation(location),!!transpose,view)};var _emscripten_glUniformMatrix2fv=_glUniformMatrix2fv;/** @suppress {duplicate } */var _glUniformMatrix3fv=(location,count,transpose,value)=>{if(count<=32){// avoid allocation when uploading few enough uniforms
count*=9;var view=miniTempWebGLFloatBuffers[count];for(var i=0;i<count;i+=9){view[i]=HEAPF32[(((value)+(4*i))>>2)];view[i+1]=HEAPF32[(((value)+(4*i+4))>>2)];view[i+2]=HEAPF32[(((value)+(4*i+8))>>2)];view[i+3]=HEAPF32[(((value)+(4*i+12))>>2)];view[i+4]=HEAPF32[(((value)+(4*i+16))>>2)];view[i+5]=HEAPF32[(((value)+(4*i+20))>>2)];view[i+6]=HEAPF32[(((value)+(4*i+24))>>2)];view[i+7]=HEAPF32[(((value)+(4*i+28))>>2)];view[i+8]=HEAPF32[(((value)+(4*i+32))>>2)]}}else{var view=HEAPF32.subarray((((value)>>2)),((value+count*36)>>2))}GLctx.uniformMatrix3fv(webglGetUniformLocation(location),!!transpose,view)};var _emscripten_glUniformMatrix3fv=_glUniformMatrix3fv;/** @suppress {duplicate } */var _glUniformMatrix4fv=(location,count,transpose,value)=>{if(count<=18){// avoid allocation when uploading few enough uniforms
var view=miniTempWebGLFloatBuffers[16*count];// hoist the heap out of the loop for size and for pthreads+growth.
var heap=HEAPF32;value=((value)>>2);count*=16;for(var i=0;i<count;i+=16){var dst=value+i;view[i]=heap[dst];view[i+1]=heap[dst+1];view[i+2]=heap[dst+2];view[i+3]=heap[dst+3];view[i+4]=heap[dst+4];view[i+5]=heap[dst+5];view[i+6]=heap[dst+6];view[i+7]=heap[dst+7];view[i+8]=heap[dst+8];view[i+9]=heap[dst+9];view[i+10]=heap[dst+10];view[i+11]=heap[dst+11];view[i+12]=heap[dst+12];view[i+13]=heap[dst+13];view[i+14]=heap[dst+14];view[i+15]=heap[dst+15]}}else{var view=HEAPF32.subarray((((value)>>2)),((value+count*64)>>2))}GLctx.uniformMatrix4fv(webglGetUniformLocation(location),!!transpose,view)};var _emscripten_glUniformMatrix4fv=_glUniformMatrix4fv;/** @suppress {duplicate } */var _glUseProgram=program=>{program=GL.programs[program];GLctx.useProgram(program);// Record the currently active program so that we can access the uniform
// mapping table of that program.
GLctx.currentProgram=program};var _emscripten_glUseProgram=_glUseProgram;/** @suppress {duplicate } */var _glValidateProgram=program=>{GLctx.validateProgram(GL.programs[program])};var _emscripten_glValidateProgram=_glValidateProgram;/** @suppress {duplicate } */var _glVertexAttrib1f=(x0,x1)=>GLctx.vertexAttrib1f(x0,x1);var _emscripten_glVertexAttrib1f=_glVertexAttrib1f;/** @suppress {duplicate } */var _glVertexAttrib1fv=(index,v)=>{GLctx.vertexAttrib1f(index,HEAPF32[v>>2])};var _emscripten_glVertexAttrib1fv=_glVertexAttrib1fv;/** @suppress {duplicate } */var _glVertexAttrib2f=(x0,x1,x2)=>GLctx.vertexAttrib2f(x0,x1,x2);var _emscripten_glVertexAttrib2f=_glVertexAttrib2f;/** @suppress {duplicate } */var _glVertexAttrib2fv=(index,v)=>{GLctx.vertexAttrib2f(index,HEAPF32[v>>2],HEAPF32[v+4>>2])};var _emscripten_glVertexAttrib2fv=_glVertexAttrib2fv;/** @suppress {duplicate } */var _glVertexAttrib3f=(x0,x1,x2,x3)=>GLctx.vertexAttrib3f(x0,x1,x2,x3);var _emscripten_glVertexAttrib3f=_glVertexAttrib3f;/** @suppress {duplicate } */var _glVertexAttrib3fv=(index,v)=>{GLctx.vertexAttrib3f(index,HEAPF32[v>>2],HEAPF32[v+4>>2],HEAPF32[v+8>>2])};var _emscripten_glVertexAttrib3fv=_glVertexAttrib3fv;/** @suppress {duplicate } */var _glVertexAttrib4f=(x0,x1,x2,x3,x4)=>GLctx.vertexAttrib4f(x0,x1,x2,x3,x4);var _emscripten_glVertexAttrib4f=_glVertexAttrib4f;/** @suppress {duplicate } */var _glVertexAttrib4fv=(index,v)=>{GLctx.vertexAttrib4f(index,HEAPF32[v>>2],HEAPF32[v+4>>2],HEAPF32[v+8>>2],HEAPF32[v+12>>2])};var _emscripten_glVertexAttrib4fv=_glVertexAttrib4fv;/** @suppress {duplicate } */var _glVertexAttribDivisor=(index,divisor)=>{GLctx.vertexAttribDivisor(index,divisor)};/** @suppress {duplicate } */var _glVertexAttribDivisorANGLE=_glVertexAttribDivisor;var _emscripten_glVertexAttribDivisorANGLE=_glVertexAttribDivisorANGLE;/** @suppress {duplicate } */var _glVertexAttribPointer=(index,size,type,normalized,stride,ptr)=>{GLctx.vertexAttribPointer(index,size,type,!!normalized,stride,ptr)};var _emscripten_glVertexAttribPointer=_glVertexAttribPointer;/** @suppress {duplicate } */var _glViewport=(x0,x1,x2,x3)=>GLctx.viewport(x0,x1,x2,x3);var _emscripten_glViewport=_glViewport;var _emscripten_has_asyncify=()=>1;var doRequestFullscreen=(target,strategy)=>{if(!JSEvents.fullscreenEnabled())return-1;target=findEventTarget(target);if(!target)return-4;if(!target.requestFullscreen&&!target.webkitRequestFullscreen){return-3}// Queue this function call if we're not currently in an event handler and
// the user saw it appropriate to do so.
if(!JSEvents.canPerformEventHandlerRequests()){if(strategy.deferUntilInEventHandler){JSEvents.deferCall(JSEvents_requestFullscreen,1,/* priority over pointer lock */[target,strategy]);return 1}return-2}return JSEvents_requestFullscreen(target,strategy)};var _emscripten_request_fullscreen_strategy=(target,deferUntilInEventHandler,fullscreenStrategy)=>{var strategy={scaleMode:HEAP32[((fullscreenStrategy)>>2)],canvasResolutionScaleMode:HEAP32[(((fullscreenStrategy)+(4))>>2)],filteringMode:HEAP32[(((fullscreenStrategy)+(8))>>2)],deferUntilInEventHandler,canvasResizedCallback:HEAP32[(((fullscreenStrategy)+(12))>>2)],canvasResizedCallbackUserData:HEAP32[(((fullscreenStrategy)+(16))>>2)]};return doRequestFullscreen(target,strategy)};var _emscripten_request_pointerlock=(target,deferUntilInEventHandler)=>{target=findEventTarget(target);if(!target)return-4;if(!target.requestPointerLock){return-1}// Queue this function call if we're not currently in an event handler and
// the user saw it appropriate to do so.
if(!JSEvents.canPerformEventHandlerRequests()){if(deferUntilInEventHandler){JSEvents.deferCall(requestPointerLock,2,/* priority below fullscreen */[target]);return 1}return-2}return requestPointerLock(target)};var abortOnCannotGrowMemory=requestedSize=>{abort("OOM")};var _emscripten_resize_heap=requestedSize=>{var oldSize=HEAPU8.length;// With CAN_ADDRESS_2GB or MEMORY64, pointers are already unsigned.
requestedSize>>>=0;abortOnCannotGrowMemory(requestedSize)};/** @suppress {checkTypes} */var _emscripten_sample_gamepad_data=()=>{try{if(navigator.getGamepads)return(JSEvents.lastGamepadState=navigator.getGamepads())?0:-1}catch(e){navigator.getGamepads=null}// Disable getGamepads() so that it won't be attempted to be used again.
return-1};var registerBeforeUnloadEventCallback=(target,userData,useCapture,callbackfunc,eventTypeId,eventTypeString)=>{var beforeUnloadEventHandlerFunc=(e=event)=>{// Note: This is always called on the main browser thread, since it needs synchronously return a value!
var confirmationMessage=((a1,a2,a3)=>dynCall_iiii(callbackfunc,a1,a2,a3))(eventTypeId,0,userData);if(confirmationMessage){confirmationMessage=UTF8ToString(confirmationMessage)}if(confirmationMessage){e.preventDefault();e.returnValue=confirmationMessage;return confirmationMessage}};var eventHandler={target:findEventTarget(target),eventTypeString,callbackfunc,handlerFunc:beforeUnloadEventHandlerFunc,useCapture};return JSEvents.registerOrRemoveHandler(eventHandler)};var _emscripten_set_beforeunload_callback_on_thread=(userData,callbackfunc,targetThread)=>{if(typeof onbeforeunload=="undefined")return-1;// beforeunload callback can only be registered on the main browser thread, because the page will go away immediately after returning from the handler,
// and there is no time to start proxying it anywhere.
if(targetThread!==1)return-5;return registerBeforeUnloadEventCallback(2,userData,true,callbackfunc,28,"beforeunload")};var registerFocusEventCallback=(target,userData,useCapture,callbackfunc,eventTypeId,eventTypeString,targetThread)=>{JSEvents.focusEvent||=_malloc(256);var focusEventHandlerFunc=(e=event)=>{var nodeName=JSEvents.getNodeNameForTarget(e.target);var id=e.target.id?e.target.id:"";var focusEvent=JSEvents.focusEvent;stringToUTF8(nodeName,focusEvent+0,128);stringToUTF8(id,focusEvent+128,128);if(((a1,a2,a3)=>dynCall_iiii(callbackfunc,a1,a2,a3))(eventTypeId,focusEvent,userData))e.preventDefault()};var eventHandler={target:findEventTarget(target),eventTypeString,callbackfunc,handlerFunc:focusEventHandlerFunc,useCapture};return JSEvents.registerOrRemoveHandler(eventHandler)};var _emscripten_set_blur_callback_on_thread=(target,userData,useCapture,callbackfunc,targetThread)=>registerFocusEventCallback(target,userData,useCapture,callbackfunc,12,"blur",targetThread);var _emscripten_set_element_css_size=(target,width,height)=>{target=findEventTarget(target);if(!target)return-4;target.style.width=width+"px";target.style.height=height+"px";return 0};var _emscripten_set_focus_callback_on_thread=(target,userData,useCapture,callbackfunc,targetThread)=>registerFocusEventCallback(target,userData,useCapture,callbackfunc,13,"focus",targetThread);var fillFullscreenChangeEventData=eventStruct=>{var fullscreenElement=document.fullscreenElement||document.mozFullScreenElement||document.webkitFullscreenElement||document.msFullscreenElement;var isFullscreen=!!fullscreenElement;// Assigning a boolean to HEAP32 with expected type coercion.
/** @suppress{checkTypes} */HEAP8[eventStruct]=isFullscreen;HEAP8[(eventStruct)+(1)]=JSEvents.fullscreenEnabled();// If transitioning to fullscreen, report info about the element that is now fullscreen.
// If transitioning to windowed mode, report info about the element that just was fullscreen.
var reportedElement=isFullscreen?fullscreenElement:JSEvents.previousFullscreenElement;var nodeName=JSEvents.getNodeNameForTarget(reportedElement);var id=reportedElement?.id||"";stringToUTF8(nodeName,eventStruct+2,128);stringToUTF8(id,eventStruct+130,128);HEAP32[(((eventStruct)+(260))>>2)]=reportedElement?reportedElement.clientWidth:0;HEAP32[(((eventStruct)+(264))>>2)]=reportedElement?reportedElement.clientHeight:0;HEAP32[(((eventStruct)+(268))>>2)]=screen.width;HEAP32[(((eventStruct)+(272))>>2)]=screen.height;if(isFullscreen){JSEvents.previousFullscreenElement=fullscreenElement}};var registerFullscreenChangeEventCallback=(target,userData,useCapture,callbackfunc,eventTypeId,eventTypeString,targetThread)=>{JSEvents.fullscreenChangeEvent||=_malloc(276);var fullscreenChangeEventhandlerFunc=(e=event)=>{var fullscreenChangeEvent=JSEvents.fullscreenChangeEvent;fillFullscreenChangeEventData(fullscreenChangeEvent);if(((a1,a2,a3)=>dynCall_iiii(callbackfunc,a1,a2,a3))(eventTypeId,fullscreenChangeEvent,userData))e.preventDefault()};var eventHandler={target,eventTypeString,callbackfunc,handlerFunc:fullscreenChangeEventhandlerFunc,useCapture};return JSEvents.registerOrRemoveHandler(eventHandler)};var _emscripten_set_fullscreenchange_callback_on_thread=(target,userData,useCapture,callbackfunc,targetThread)=>{if(!JSEvents.fullscreenEnabled())return-1;target=findEventTarget(target);if(!target)return-4;// Unprefixed Fullscreen API shipped in Chromium 71 (https://bugs.chromium.org/p/chromium/issues/detail?id=383813)
// As of Safari 13.0.3 on macOS Catalina 10.15.1 still ships with prefixed webkitfullscreenchange. TODO: revisit this check once Safari ships unprefixed version.
registerFullscreenChangeEventCallback(target,userData,useCapture,callbackfunc,19,"webkitfullscreenchange",targetThread);return registerFullscreenChangeEventCallback(target,userData,useCapture,callbackfunc,19,"fullscreenchange",targetThread)};var registerGamepadEventCallback=(target,userData,useCapture,callbackfunc,eventTypeId,eventTypeString,targetThread)=>{JSEvents.gamepadEvent||=_malloc(1240);var gamepadEventHandlerFunc=(e=event)=>{var gamepadEvent=JSEvents.gamepadEvent;fillGamepadEventData(gamepadEvent,e["gamepad"]);if(((a1,a2,a3)=>dynCall_iiii(callbackfunc,a1,a2,a3))(eventTypeId,gamepadEvent,userData))e.preventDefault()};var eventHandler={target:findEventTarget(target),allowsDeferredCalls:true,eventTypeString,callbackfunc,handlerFunc:gamepadEventHandlerFunc,useCapture};return JSEvents.registerOrRemoveHandler(eventHandler)};var _emscripten_set_gamepadconnected_callback_on_thread=(userData,useCapture,callbackfunc,targetThread)=>{if(_emscripten_sample_gamepad_data())return-1;return registerGamepadEventCallback(2,userData,useCapture,callbackfunc,26,"gamepadconnected",targetThread)};var _emscripten_set_gamepaddisconnected_callback_on_thread=(userData,useCapture,callbackfunc,targetThread)=>{if(_emscripten_sample_gamepad_data())return-1;return registerGamepadEventCallback(2,userData,useCapture,callbackfunc,27,"gamepaddisconnected",targetThread)};var registerKeyEventCallback=(target,userData,useCapture,callbackfunc,eventTypeId,eventTypeString,targetThread)=>{JSEvents.keyEvent||=_malloc(160);var keyEventHandlerFunc=e=>{var keyEventData=JSEvents.keyEvent;HEAPF64[((keyEventData)>>3)]=e.timeStamp;var idx=((keyEventData)>>2);HEAP32[idx+2]=e.location;HEAP8[keyEventData+12]=e.ctrlKey;HEAP8[keyEventData+13]=e.shiftKey;HEAP8[keyEventData+14]=e.altKey;HEAP8[keyEventData+15]=e.metaKey;HEAP8[keyEventData+16]=e.repeat;HEAP32[idx+5]=e.charCode;HEAP32[idx+6]=e.keyCode;HEAP32[idx+7]=e.which;stringToUTF8(e.key||"",keyEventData+32,32);stringToUTF8(e.code||"",keyEventData+64,32);stringToUTF8(e.char||"",keyEventData+96,32);stringToUTF8(e.locale||"",keyEventData+128,32);if(((a1,a2,a3)=>dynCall_iiii(callbackfunc,a1,a2,a3))(eventTypeId,keyEventData,userData))e.preventDefault()};var eventHandler={target:findEventTarget(target),eventTypeString,callbackfunc,handlerFunc:keyEventHandlerFunc,useCapture};return JSEvents.registerOrRemoveHandler(eventHandler)};var _emscripten_set_keydown_callback_on_thread=(target,userData,useCapture,callbackfunc,targetThread)=>registerKeyEventCallback(target,userData,useCapture,callbackfunc,2,"keydown",targetThread);var _emscripten_set_keypress_callback_on_thread=(target,userData,useCapture,callbackfunc,targetThread)=>registerKeyEventCallback(target,userData,useCapture,callbackfunc,1,"keypress",targetThread);var _emscripten_set_keyup_callback_on_thread=(target,userData,useCapture,callbackfunc,targetThread)=>registerKeyEventCallback(target,userData,useCapture,callbackfunc,3,"keyup",targetThread);var _emscripten_set_main_loop=(func,fps,simulateInfiniteLoop)=>{var iterFunc=(()=>dynCall_v(func));setMainLoop(iterFunc,fps,simulateInfiniteLoop)};var fillMouseEventData=(eventStruct,e,target)=>{HEAPF64[((eventStruct)>>3)]=e.timeStamp;var idx=((eventStruct)>>2);HEAP32[idx+2]=e.screenX;HEAP32[idx+3]=e.screenY;HEAP32[idx+4]=e.clientX;HEAP32[idx+5]=e.clientY;HEAP8[eventStruct+24]=e.ctrlKey;HEAP8[eventStruct+25]=e.shiftKey;HEAP8[eventStruct+26]=e.altKey;HEAP8[eventStruct+27]=e.metaKey;HEAP16[idx*2+14]=e.button;HEAP16[idx*2+15]=e.buttons;HEAP32[idx+8]=e["movementX"];HEAP32[idx+9]=e["movementY"];// Note: rect contains doubles (truncated to placate SAFE_HEAP, which is the same behaviour when writing to HEAP32 anyway)
var rect=getBoundingClientRect(target);HEAP32[idx+10]=e.clientX-(rect.left|0);HEAP32[idx+11]=e.clientY-(rect.top|0)};var registerMouseEventCallback=(target,userData,useCapture,callbackfunc,eventTypeId,eventTypeString,targetThread)=>{JSEvents.mouseEvent||=_malloc(64);target=findEventTarget(target);var mouseEventHandlerFunc=(e=event)=>{// TODO: Make this access thread safe, or this could update live while app is reading it.
fillMouseEventData(JSEvents.mouseEvent,e,target);if(((a1,a2,a3)=>dynCall_iiii(callbackfunc,a1,a2,a3))(eventTypeId,JSEvents.mouseEvent,userData))e.preventDefault()};var eventHandler={target,allowsDeferredCalls:eventTypeString!="mousemove"&&eventTypeString!="mouseenter"&&eventTypeString!="mouseleave",// Mouse move events do not allow fullscreen/pointer lock requests to be handled in them!
eventTypeString,callbackfunc,handlerFunc:mouseEventHandlerFunc,useCapture};return JSEvents.registerOrRemoveHandler(eventHandler)};var _emscripten_set_mousedown_callback_on_thread=(target,userData,useCapture,callbackfunc,targetThread)=>registerMouseEventCallback(target,userData,useCapture,callbackfunc,5,"mousedown",targetThread);var _emscripten_set_mouseenter_callback_on_thread=(target,userData,useCapture,callbackfunc,targetThread)=>registerMouseEventCallback(target,userData,useCapture,callbackfunc,33,"mouseenter",targetThread);var _emscripten_set_mouseleave_callback_on_thread=(target,userData,useCapture,callbackfunc,targetThread)=>registerMouseEventCallback(target,userData,useCapture,callbackfunc,34,"mouseleave",targetThread);var _emscripten_set_mousemove_callback_on_thread=(target,userData,useCapture,callbackfunc,targetThread)=>registerMouseEventCallback(target,userData,useCapture,callbackfunc,8,"mousemove",targetThread);var _emscripten_set_mouseup_callback_on_thread=(target,userData,useCapture,callbackfunc,targetThread)=>registerMouseEventCallback(target,userData,useCapture,callbackfunc,6,"mouseup",targetThread);var fillPointerlockChangeEventData=eventStruct=>{var pointerLockElement=document.pointerLockElement||document.mozPointerLockElement||document.webkitPointerLockElement||document.msPointerLockElement;var isPointerlocked=!!pointerLockElement;// Assigning a boolean to HEAP32 with expected type coercion.
/** @suppress{checkTypes} */HEAP8[eventStruct]=isPointerlocked;var nodeName=JSEvents.getNodeNameForTarget(pointerLockElement);var id=pointerLockElement?.id||"";stringToUTF8(nodeName,eventStruct+1,128);stringToUTF8(id,eventStruct+129,128)};var registerPointerlockChangeEventCallback=(target,userData,useCapture,callbackfunc,eventTypeId,eventTypeString,targetThread)=>{JSEvents.pointerlockChangeEvent||=_malloc(257);var pointerlockChangeEventHandlerFunc=(e=event)=>{var pointerlockChangeEvent=JSEvents.pointerlockChangeEvent;fillPointerlockChangeEventData(pointerlockChangeEvent);if(((a1,a2,a3)=>dynCall_iiii(callbackfunc,a1,a2,a3))(eventTypeId,pointerlockChangeEvent,userData))e.preventDefault()};var eventHandler={target,eventTypeString,callbackfunc,handlerFunc:pointerlockChangeEventHandlerFunc,useCapture};return JSEvents.registerOrRemoveHandler(eventHandler)};/** @suppress {missingProperties} */var _emscripten_set_pointerlockchange_callback_on_thread=(target,userData,useCapture,callbackfunc,targetThread)=>{// TODO: Currently not supported in pthreads or in --proxy-to-worker mode. (In pthreads mode, document object is not defined)
if(!document||!document.body||(!document.body.requestPointerLock&&!document.body.mozRequestPointerLock&&!document.body.webkitRequestPointerLock&&!document.body.msRequestPointerLock)){return-1}target=findEventTarget(target);if(!target)return-4;registerPointerlockChangeEventCallback(target,userData,useCapture,callbackfunc,20,"mozpointerlockchange",targetThread);registerPointerlockChangeEventCallback(target,userData,useCapture,callbackfunc,20,"webkitpointerlockchange",targetThread);registerPointerlockChangeEventCallback(target,userData,useCapture,callbackfunc,20,"mspointerlockchange",targetThread);return registerPointerlockChangeEventCallback(target,userData,useCapture,callbackfunc,20,"pointerlockchange",targetThread)};var registerUiEventCallback=(target,userData,useCapture,callbackfunc,eventTypeId,eventTypeString,targetThread)=>{JSEvents.uiEvent||=_malloc(36);target=findEventTarget(target);var uiEventHandlerFunc=(e=event)=>{if(e.target!=target){// Never take ui events such as scroll via a 'bubbled' route, but always from the direct element that
// was targeted. Otherwise e.g. if app logs a message in response to a page scroll, the Emscripten log
// message box could cause to scroll, generating a new (bubbled) scroll message, causing a new log print,
// causing a new scroll, etc..
return}var b=document.body;// Take document.body to a variable, Closure compiler does not outline access to it on its own.
if(!b){// During a page unload 'body' can be null, with "Cannot read property 'clientWidth' of null" being thrown
return}var uiEvent=JSEvents.uiEvent;HEAP32[((uiEvent)>>2)]=0;// always zero for resize and scroll
HEAP32[(((uiEvent)+(4))>>2)]=b.clientWidth;HEAP32[(((uiEvent)+(8))>>2)]=b.clientHeight;HEAP32[(((uiEvent)+(12))>>2)]=innerWidth;HEAP32[(((uiEvent)+(16))>>2)]=innerHeight;HEAP32[(((uiEvent)+(20))>>2)]=outerWidth;HEAP32[(((uiEvent)+(24))>>2)]=outerHeight;HEAP32[(((uiEvent)+(28))>>2)]=pageXOffset|0;// scroll offsets are float
HEAP32[(((uiEvent)+(32))>>2)]=pageYOffset|0;if(((a1,a2,a3)=>dynCall_iiii(callbackfunc,a1,a2,a3))(eventTypeId,uiEvent,userData))e.preventDefault()};var eventHandler={target,eventTypeString,callbackfunc,handlerFunc:uiEventHandlerFunc,useCapture};return JSEvents.registerOrRemoveHandler(eventHandler)};var _emscripten_set_resize_callback_on_thread=(target,userData,useCapture,callbackfunc,targetThread)=>registerUiEventCallback(target,userData,useCapture,callbackfunc,10,"resize",targetThread);var registerTouchEventCallback=(target,userData,useCapture,callbackfunc,eventTypeId,eventTypeString,targetThread)=>{JSEvents.touchEvent||=_malloc(1552);target=findEventTarget(target);var touchEventHandlerFunc=e=>{var t,touches={},et=e.touches;// To ease marshalling different kinds of touches that browser reports (all touches are listed in e.touches,
// only changed touches in e.changedTouches, and touches on target at a.targetTouches), mark a boolean in
// each Touch object so that we can later loop only once over all touches we see to marshall over to Wasm.
for(let t of et){// Browser might recycle the generated Touch objects between each frame (Firefox on Android), so reset any
// changed/target states we may have set from previous frame.
t.isChanged=t.onTarget=0;touches[t.identifier]=t}// Mark which touches are part of the changedTouches list.
for(let t of e.changedTouches){t.isChanged=1;touches[t.identifier]=t}// Mark which touches are part of the targetTouches list.
for(let t of e.targetTouches){touches[t.identifier].onTarget=1}var touchEvent=JSEvents.touchEvent;HEAPF64[((touchEvent)>>3)]=e.timeStamp;HEAP8[touchEvent+12]=e.ctrlKey;HEAP8[touchEvent+13]=e.shiftKey;HEAP8[touchEvent+14]=e.altKey;HEAP8[touchEvent+15]=e.metaKey;var idx=touchEvent+16;var targetRect=getBoundingClientRect(target);var numTouches=0;for(let t of Object.values(touches)){var idx32=((idx)>>2);// Pre-shift the ptr to index to HEAP32 to save code size
HEAP32[idx32+0]=t.identifier;HEAP32[idx32+1]=t.screenX;HEAP32[idx32+2]=t.screenY;HEAP32[idx32+3]=t.clientX;HEAP32[idx32+4]=t.clientY;HEAP32[idx32+5]=t.pageX;HEAP32[idx32+6]=t.pageY;HEAP8[idx+28]=t.isChanged;HEAP8[idx+29]=t.onTarget;HEAP32[idx32+8]=t.clientX-(targetRect.left|0);HEAP32[idx32+9]=t.clientY-(targetRect.top|0);idx+=48;if(++numTouches>31){break}}HEAP32[(((touchEvent)+(8))>>2)]=numTouches;if(((a1,a2,a3)=>dynCall_iiii(callbackfunc,a1,a2,a3))(eventTypeId,touchEvent,userData))e.preventDefault()};var eventHandler={target,allowsDeferredCalls:eventTypeString=="touchstart"||eventTypeString=="touchend",eventTypeString,callbackfunc,handlerFunc:touchEventHandlerFunc,useCapture};return JSEvents.registerOrRemoveHandler(eventHandler)};var _emscripten_set_touchcancel_callback_on_thread=(target,userData,useCapture,callbackfunc,targetThread)=>registerTouchEventCallback(target,userData,useCapture,callbackfunc,25,"touchcancel",targetThread);var _emscripten_set_touchend_callback_on_thread=(target,userData,useCapture,callbackfunc,targetThread)=>registerTouchEventCallback(target,userData,useCapture,callbackfunc,23,"touchend",targetThread);var _emscripten_set_touchmove_callback_on_thread=(target,userData,useCapture,callbackfunc,targetThread)=>registerTouchEventCallback(target,userData,useCapture,callbackfunc,24,"touchmove",targetThread);var _emscripten_set_touchstart_callback_on_thread=(target,userData,useCapture,callbackfunc,targetThread)=>registerTouchEventCallback(target,userData,useCapture,callbackfunc,22,"touchstart",targetThread);var fillVisibilityChangeEventData=eventStruct=>{var visibilityStates=["hidden","visible","prerender","unloaded"];var visibilityState=visibilityStates.indexOf(document.visibilityState);// Assigning a boolean to HEAP32 with expected type coercion.
/** @suppress{checkTypes} */HEAP8[eventStruct]=document.hidden;HEAP32[(((eventStruct)+(4))>>2)]=visibilityState};var registerVisibilityChangeEventCallback=(target,userData,useCapture,callbackfunc,eventTypeId,eventTypeString,targetThread)=>{JSEvents.visibilityChangeEvent||=_malloc(8);var visibilityChangeEventHandlerFunc=(e=event)=>{var visibilityChangeEvent=JSEvents.visibilityChangeEvent;fillVisibilityChangeEventData(visibilityChangeEvent);if(((a1,a2,a3)=>dynCall_iiii(callbackfunc,a1,a2,a3))(eventTypeId,visibilityChangeEvent,userData))e.preventDefault()};var eventHandler={target,eventTypeString,callbackfunc,handlerFunc:visibilityChangeEventHandlerFunc,useCapture};return JSEvents.registerOrRemoveHandler(eventHandler)};var _emscripten_set_visibilitychange_callback_on_thread=(userData,useCapture,callbackfunc,targetThread)=>registerVisibilityChangeEventCallback(specialHTMLTargets[1],userData,useCapture,callbackfunc,21,"visibilitychange",targetThread);var registerWheelEventCallback=(target,userData,useCapture,callbackfunc,eventTypeId,eventTypeString,targetThread)=>{JSEvents.wheelEvent||=_malloc(96);// The DOM Level 3 events spec event 'wheel'
var wheelHandlerFunc=(e=event)=>{var wheelEvent=JSEvents.wheelEvent;fillMouseEventData(wheelEvent,e,target);HEAPF64[(((wheelEvent)+(64))>>3)]=e["deltaX"];HEAPF64[(((wheelEvent)+(72))>>3)]=e["deltaY"];HEAPF64[(((wheelEvent)+(80))>>3)]=e["deltaZ"];HEAP32[(((wheelEvent)+(88))>>2)]=e["deltaMode"];if(((a1,a2,a3)=>dynCall_iiii(callbackfunc,a1,a2,a3))(eventTypeId,wheelEvent,userData))e.preventDefault()};var eventHandler={target,allowsDeferredCalls:true,eventTypeString,callbackfunc,handlerFunc:wheelHandlerFunc,useCapture};return JSEvents.registerOrRemoveHandler(eventHandler)};var _emscripten_set_wheel_callback_on_thread=(target,userData,useCapture,callbackfunc,targetThread)=>{target=findEventTarget(target);if(!target)return-4;if(typeof target.onwheel!="undefined"){return registerWheelEventCallback(target,userData,useCapture,callbackfunc,9,"wheel",targetThread)}else{return-1}};var _emscripten_set_window_title=title=>document.title=UTF8ToString(title);var _emscripten_sleep=ms=>Asyncify.handleSleep(wakeUp=>safeSetTimeout(wakeUp,ms));_emscripten_sleep.isAsync=true;var ENV={};var getExecutableName=()=>thisProgram||"./this.program";var getEnvStrings=()=>{if(!getEnvStrings.strings){// Default values.
// Browser language detection #8751
var lang=((typeof navigator=="object"&&navigator.languages&&navigator.languages[0])||"C").replace("-","_")+".UTF-8";var env={"USER":"web_user","LOGNAME":"web_user","PATH":"/","PWD":"/","HOME":"/home/web_user","LANG":lang,"_":getExecutableName()};// Apply the user-provided values, if any.
for(var x in ENV){// x is a key in ENV; if ENV[x] is undefined, that means it was
// explicitly set to be so. We allow user code to do that to
// force variables with default values to remain unset.
if(ENV[x]===undefined)delete env[x];else env[x]=ENV[x]}var strings=[];for(var x in env){strings.push(`${x}=${env[x]}`)}getEnvStrings.strings=strings}return getEnvStrings.strings};var stringToAscii=(str,buffer)=>{for(var i=0;i<str.length;++i){HEAP8[buffer++]=str.charCodeAt(i)}// Null-terminate the string
HEAP8[buffer]=0};var _environ_get=(__environ,environ_buf)=>{var bufSize=0;getEnvStrings().forEach((string,i)=>{var ptr=environ_buf+bufSize;HEAPU32[(((__environ)+(i*4))>>2)]=ptr;stringToAscii(string,ptr);bufSize+=string.length+1});return 0};var _environ_sizes_get=(penviron_count,penviron_buf_size)=>{var strings=getEnvStrings();HEAPU32[((penviron_count)>>2)]=strings.length;var bufSize=0;strings.forEach(string=>bufSize+=string.length+1);HEAPU32[((penviron_buf_size)>>2)]=bufSize;return 0};var _fd_close=fd=>52;var _fd_read=(fd,iov,iovcnt,pnum)=>52;var convertI32PairToI53Checked=(lo,hi)=>((hi+2097152)>>>0<4194305-!!lo)?(lo>>>0)+hi*4294967296:NaN;function _fd_seek(fd,offset_low,offset_high,whence,newOffset){var offset=convertI32PairToI53Checked(offset_low,offset_high);return 70}var printCharBuffers=[null,[],[]];var printChar=(stream,curr)=>{var buffer=printCharBuffers[stream];if(curr===0||curr===10){(stream===1?out:err)(UTF8ArrayToString(buffer,0));buffer.length=0}else{buffer.push(curr)}};var _fd_write=(fd,iov,iovcnt,pnum)=>{// hack to support printf in SYSCALLS_REQUIRE_FILESYSTEM=0
var num=0;for(var i=0;i<iovcnt;i++){var ptr=HEAPU32[((iov)>>2)];var len=HEAPU32[(((iov)+(4))>>2)];iov+=8;for(var j=0;j<len;j++){printChar(fd,HEAPU8[ptr+j])}num+=len}HEAPU32[((pnum)>>2)]=num;return 0};var listenOnce=(object,event,func)=>{object.addEventListener(event,func,{"once":true})};/** @param {Object=} elements */var autoResumeAudioContext=(ctx,elements)=>{if(!elements){elements=[document,document.getElementById("canvas")]}["keydown","mousedown","touchstart"].forEach(event=>{elements.forEach(element=>{if(element){listenOnce(element,event,()=>{if(ctx.state==="suspended")ctx.resume()})}})})};var dynCallLegacy=(sig,ptr,args)=>{sig=sig.replace(/p/g,"i");var f=Module["dynCall_"+sig];return f(ptr,...args)};/** @type {WebAssembly.Table} */var wasmTable;var dynCall=(sig,ptr,args=[])=>{var rtn=dynCallLegacy(sig,ptr,args);return rtn};var runAndAbortIfError=func=>{try{return func()}catch(e){abort(e)}};var Asyncify={instrumentWasmImports(imports){var importPattern=/^(invoke_.*|__asyncjs__.*)$/;for(let[x,original]of Object.entries(imports)){if(typeof original=="function"){let isAsyncifyImport=original.isAsync||importPattern.test(x)}}},instrumentWasmExports(exports){var ret={};for(let[x,original]of Object.entries(exports)){if(typeof original=="function"){ret[x]=(...args)=>{Asyncify.exportCallStack.push(x);try{return original(...args)}finally{if(!ABORT){var y=Asyncify.exportCallStack.pop();Asyncify.maybeStopUnwind()}}}}else{ret[x]=original}}return ret},State:{Normal:0,Unwinding:1,Rewinding:2,Disabled:3},state:0,StackSize:4096,currData:null,handleSleepReturnValue:0,exportCallStack:[],callStackNameToId:{},callStackIdToName:{},callStackId:0,asyncPromiseHandlers:null,sleepCallbacks:[],getCallStackId(funcName){var id=Asyncify.callStackNameToId[funcName];if(id===undefined){id=Asyncify.callStackId++;Asyncify.callStackNameToId[funcName]=id;Asyncify.callStackIdToName[id]=funcName}return id},maybeStopUnwind(){if(Asyncify.currData&&Asyncify.state===Asyncify.State.Unwinding&&Asyncify.exportCallStack.length===0){// We just finished unwinding.
// Be sure to set the state before calling any other functions to avoid
// possible infinite recursion here (For example in debug pthread builds
// the dbg() function itself can call back into WebAssembly to get the
// current pthread_self() pointer).
Asyncify.state=Asyncify.State.Normal;// Keep the runtime alive so that a re-wind can be done later.
runAndAbortIfError(_asyncify_stop_unwind);if(typeof Fibers!="undefined"){Fibers.trampoline()}}},whenDone(){return new Promise((resolve,reject)=>{Asyncify.asyncPromiseHandlers={resolve,reject}})},allocateData(){// An asyncify data structure has three fields:
//  0  current stack pos
//  4  max stack pos
//  8  id of function at bottom of the call stack (callStackIdToName[id] == name of js function)
// The Asyncify ABI only interprets the first two fields, the rest is for the runtime.
// We also embed a stack in the same memory region here, right next to the structure.
// This struct is also defined as asyncify_data_t in emscripten/fiber.h
var ptr=_malloc(12+Asyncify.StackSize);Asyncify.setDataHeader(ptr,ptr+12,Asyncify.StackSize);Asyncify.setDataRewindFunc(ptr);return ptr},setDataHeader(ptr,stack,stackSize){HEAPU32[((ptr)>>2)]=stack;HEAPU32[(((ptr)+(4))>>2)]=stack+stackSize},setDataRewindFunc(ptr){var bottomOfCallStack=Asyncify.exportCallStack[0];var rewindId=Asyncify.getCallStackId(bottomOfCallStack);HEAP32[(((ptr)+(8))>>2)]=rewindId},getDataRewindFuncName(ptr){var id=HEAP32[(((ptr)+(8))>>2)];var name=Asyncify.callStackIdToName[id];return name},getDataRewindFunc(name){var func=wasmExports[name];return func},doRewind(ptr){var name=Asyncify.getDataRewindFuncName(ptr);var func=Asyncify.getDataRewindFunc(name);// Once we have rewound and the stack we no longer need to artificially
// keep the runtime alive.
return func()},handleSleep(startAsync){if(ABORT)return;if(Asyncify.state===Asyncify.State.Normal){// Prepare to sleep. Call startAsync, and see what happens:
// if the code decided to call our callback synchronously,
// then no async operation was in fact begun, and we don't
// need to do anything.
var reachedCallback=false;var reachedAfterCallback=false;startAsync((handleSleepReturnValue=0)=>{if(ABORT)return;Asyncify.handleSleepReturnValue=handleSleepReturnValue;reachedCallback=true;if(!reachedAfterCallback){// We are happening synchronously, so no need for async.
return}Asyncify.state=Asyncify.State.Rewinding;runAndAbortIfError(()=>_asyncify_start_rewind(Asyncify.currData));if(typeof MainLoop!="undefined"&&MainLoop.func){MainLoop.resume()}var asyncWasmReturnValue,isError=false;try{asyncWasmReturnValue=Asyncify.doRewind(Asyncify.currData)}catch(err){asyncWasmReturnValue=err;isError=true}// Track whether the return value was handled by any promise handlers.
var handled=false;if(!Asyncify.currData){// All asynchronous execution has finished.
// `asyncWasmReturnValue` now contains the final
// return value of the exported async WASM function.
// Note: `asyncWasmReturnValue` is distinct from
// `Asyncify.handleSleepReturnValue`.
// `Asyncify.handleSleepReturnValue` contains the return
// value of the last C function to have executed
// `Asyncify.handleSleep()`, where as `asyncWasmReturnValue`
// contains the return value of the exported WASM function
// that may have called C functions that
// call `Asyncify.handleSleep()`.
var asyncPromiseHandlers=Asyncify.asyncPromiseHandlers;if(asyncPromiseHandlers){Asyncify.asyncPromiseHandlers=null;(isError?asyncPromiseHandlers.reject:asyncPromiseHandlers.resolve)(asyncWasmReturnValue);handled=true}}if(isError&&!handled){// If there was an error and it was not handled by now, we have no choice but to
// rethrow that error into the global scope where it can be caught only by
// `onerror` or `onunhandledpromiserejection`.
throw asyncWasmReturnValue}});reachedAfterCallback=true;if(!reachedCallback){// A true async operation was begun; start a sleep.
Asyncify.state=Asyncify.State.Unwinding;// TODO: reuse, don't alloc/free every sleep
Asyncify.currData=Asyncify.allocateData();if(typeof MainLoop!="undefined"&&MainLoop.func){MainLoop.pause()}runAndAbortIfError(()=>_asyncify_start_unwind(Asyncify.currData))}}else if(Asyncify.state===Asyncify.State.Rewinding){// Stop a resume.
Asyncify.state=Asyncify.State.Normal;runAndAbortIfError(_asyncify_stop_rewind);_free(Asyncify.currData);Asyncify.currData=null;// Call all sleep callbacks now that the sleep-resume is all done.
Asyncify.sleepCallbacks.forEach(callUserCallback)}else{abort(`invalid state: ${Asyncify.state}`)}return Asyncify.handleSleepReturnValue},handleAsync(startAsync){return Asyncify.handleSleep(wakeUp=>{// TODO: add error handling as a second param when handleSleep implements it.
startAsync().then(wakeUp)})}};// exports
Module["requestFullscreen"]=Browser.requestFullscreen;Module["setCanvasSize"]=Browser.setCanvasSize;Module["getUserMedia"]=Browser.getUserMedia;Module["createContext"]=Browser.createContext;Module["requestAnimationFrame"]=MainLoop.requestAnimationFrame;Module["pauseMainLoop"]=MainLoop.pause;Module["resumeMainLoop"]=MainLoop.resume;MainLoop.init();for(var i=0;i<32;++i)tempFixedLengthArray.push(new Array(i));var miniTempWebGLFloatBuffersStorage=new Float32Array(288);// Create GL_POOL_TEMP_BUFFERS_SIZE+1 temporary buffers, for uploads of size 0 through GL_POOL_TEMP_BUFFERS_SIZE inclusive
for(/**@suppress{duplicate}*/var i=0;i<=288;++i){miniTempWebGLFloatBuffers[i]=miniTempWebGLFloatBuffersStorage.subarray(0,i)}var miniTempWebGLIntBuffersStorage=new Int32Array(288);// Create GL_POOL_TEMP_BUFFERS_SIZE+1 temporary buffers, for uploads of size 0 through GL_POOL_TEMP_BUFFERS_SIZE inclusive
for(/**@suppress{duplicate}*/var i=0;i<=288;++i){miniTempWebGLIntBuffers[i]=miniTempWebGLIntBuffersStorage.subarray(0,i)}var wasmImports={/** @export */jb:___call_sighandler,/** @export */m:___syscall_fcntl64,/** @export */ub:___syscall_ioctl,/** @export */wb:___syscall_openat,/** @export */zb:__abort_js,/** @export */xb:__emscripten_get_now_is_monotonic,/** @export */rb:__emscripten_memcpy_js,/** @export */lb:__emscripten_runtime_keepalive_clear,/** @export */nb:__setitimer_js,/** @export */Kb:_eglBindAPI,/** @export */Wb:_eglChooseConfig,/** @export */Ub:_eglCreateContext,/** @export */Sb:_eglCreateWindowSurface,/** @export */Tb:_eglDestroyContext,/** @export */Rb:_eglDestroySurface,/** @export */Vb:_eglGetConfigAttrib,/** @export */J:_eglGetDisplay,/** @export */Ib:_eglGetError,/** @export */Zb:_eglInitialize,/** @export */Qb:_eglMakeCurrent,/** @export */Jb:_eglQueryString,/** @export */Pb:_eglSwapBuffers,/** @export */Ob:_eglSwapInterval,/** @export */Xb:_eglTerminate,/** @export */Lb:_eglWaitGL,/** @export */Mb:_eglWaitNative,/** @export */za:_emscripten_asm_const_int,/** @export */a:_emscripten_asm_const_int_sync_on_main_thread,/** @export */k:_emscripten_asm_const_ptr_sync_on_main_thread,/** @export */H:_emscripten_cancel_main_loop,/** @export */yb:_emscripten_date_now,/** @export */Ab:_emscripten_exit_fullscreen,/** @export */Gb:_emscripten_exit_pointerlock,/** @export */cb:_emscripten_force_exit,/** @export */d:_emscripten_get_device_pixel_ratio,/** @export */b:_emscripten_get_element_css_size,/** @export */_b:_emscripten_get_gamepad_status,/** @export */e:_emscripten_get_now,/** @export */$b:_emscripten_get_num_gamepads,/** @export */Hb:_emscripten_get_screen_size,/** @export */gb:_emscripten_glActiveTexture,/** @export */fb:_emscripten_glAttachShader,/** @export */zd:_emscripten_glBeginQueryEXT,/** @export */eb:_emscripten_glBindAttribLocation,/** @export */db:_emscripten_glBindBuffer,/** @export */bb:_emscripten_glBindFramebuffer,/** @export */ab:_emscripten_glBindRenderbuffer,/** @export */$a:_emscripten_glBindTexture,/** @export */Yb:_emscripten_glBindVertexArrayOES,/** @export */_a:_emscripten_glBlendColor,/** @export */Za:_emscripten_glBlendEquation,/** @export */Ya:_emscripten_glBlendEquationSeparate,/** @export */Xa:_emscripten_glBlendFunc,/** @export */Wa:_emscripten_glBlendFuncSeparate,/** @export */Va:_emscripten_glBufferData,/** @export */Ua:_emscripten_glBufferSubData,/** @export */Ta:_emscripten_glCheckFramebufferStatus,/** @export */Sa:_emscripten_glClear,/** @export */Ra:_emscripten_glClearColor,/** @export */Qa:_emscripten_glClearDepthf,/** @export */Pa:_emscripten_glClearStencil,/** @export */dc:_emscripten_glClipControlEXT,/** @export */Oa:_emscripten_glColorMask,/** @export */Na:_emscripten_glCompileShader,/** @export */Ma:_emscripten_glCompressedTexImage2D,/** @export */La:_emscripten_glCompressedTexSubImage2D,/** @export */Ka:_emscripten_glCopyTexImage2D,/** @export */Ja:_emscripten_glCopyTexSubImage2D,/** @export */Ia:_emscripten_glCreateProgram,/** @export */Ha:_emscripten_glCreateShader,/** @export */Ga:_emscripten_glCullFace,/** @export */Fa:_emscripten_glDeleteBuffers,/** @export */Ea:_emscripten_glDeleteFramebuffers,/** @export */Da:_emscripten_glDeleteProgram,/** @export */da:_emscripten_glDeleteQueriesEXT,/** @export */Ca:_emscripten_glDeleteRenderbuffers,/** @export */Ba:_emscripten_glDeleteShader,/** @export */Aa:_emscripten_glDeleteTextures,/** @export */Nb:_emscripten_glDeleteVertexArraysOES,/** @export */ya:_emscripten_glDepthFunc,/** @export */xa:_emscripten_glDepthMask,/** @export */wa:_emscripten_glDepthRangef,/** @export */va:_emscripten_glDetachShader,/** @export */ua:_emscripten_glDisable,/** @export */ta:_emscripten_glDisableVertexAttribArray,/** @export */sa:_emscripten_glDrawArrays,/** @export */vb:_emscripten_glDrawArraysInstancedANGLE,/** @export */Db:_emscripten_glDrawBuffersWEBGL,/** @export */ra:_emscripten_glDrawElements,/** @export */mb:_emscripten_glDrawElementsInstancedANGLE,/** @export */qa:_emscripten_glEnable,/** @export */pa:_emscripten_glEnableVertexAttribArray,/** @export */od:_emscripten_glEndQueryEXT,/** @export */na:_emscripten_glFinish,/** @export */ma:_emscripten_glFlush,/** @export */la:_emscripten_glFramebufferRenderbuffer,/** @export */ka:_emscripten_glFramebufferTexture2D,/** @export */ja:_emscripten_glFrontFace,/** @export */ia:_emscripten_glGenBuffers,/** @export */ga:_emscripten_glGenFramebuffers,/** @export */oa:_emscripten_glGenQueriesEXT,/** @export */fa:_emscripten_glGenRenderbuffers,/** @export */ea:_emscripten_glGenTextures,/** @export */Fb:_emscripten_glGenVertexArraysOES,/** @export */ha:_emscripten_glGenerateMipmap,/** @export */ca:_emscripten_glGetActiveAttrib,/** @export */ba:_emscripten_glGetActiveUniform,/** @export */aa:_emscripten_glGetAttachedShaders,/** @export */$:_emscripten_glGetAttribLocation,/** @export */_:_emscripten_glGetBooleanv,/** @export */Z:_emscripten_glGetBufferParameteriv,/** @export */Y:_emscripten_glGetError,/** @export */X:_emscripten_glGetFloatv,/** @export */W:_emscripten_glGetFramebufferAttachmentParameteriv,/** @export */V:_emscripten_glGetIntegerv,/** @export */S:_emscripten_glGetProgramInfoLog,/** @export */T:_emscripten_glGetProgramiv,/** @export */nc:_emscripten_glGetQueryObjecti64vEXT,/** @export */Jc:_emscripten_glGetQueryObjectivEXT,/** @export */cc:_emscripten_glGetQueryObjectui64vEXT,/** @export */yc:_emscripten_glGetQueryObjectuivEXT,/** @export */Uc:_emscripten_glGetQueryivEXT,/** @export */R:_emscripten_glGetRenderbufferParameteriv,/** @export */P:_emscripten_glGetShaderInfoLog,/** @export */O:_emscripten_glGetShaderPrecisionFormat,/** @export */N:_emscripten_glGetShaderSource,/** @export */Q:_emscripten_glGetShaderiv,/** @export */M:_emscripten_glGetString,/** @export */L:_emscripten_glGetTexParameterfv,/** @export */K:_emscripten_glGetTexParameteriv,/** @export */wd:_emscripten_glGetUniformLocation,/** @export */yd:_emscripten_glGetUniformfv,/** @export */xd:_emscripten_glGetUniformiv,/** @export */td:_emscripten_glGetVertexAttribPointerv,/** @export */vd:_emscripten_glGetVertexAttribfv,/** @export */ud:_emscripten_glGetVertexAttribiv,/** @export */sd:_emscripten_glHint,/** @export */rd:_emscripten_glIsBuffer,/** @export */qd:_emscripten_glIsEnabled,/** @export */pd:_emscripten_glIsFramebuffer,/** @export */nd:_emscripten_glIsProgram,/** @export */U:_emscripten_glIsQueryEXT,/** @export */md:_emscripten_glIsRenderbuffer,/** @export */ld:_emscripten_glIsShader,/** @export */kd:_emscripten_glIsTexture,/** @export */Eb:_emscripten_glIsVertexArrayOES,/** @export */jd:_emscripten_glLineWidth,/** @export */id:_emscripten_glLinkProgram,/** @export */hd:_emscripten_glPixelStorei,/** @export */bc:_emscripten_glPolygonModeWEBGL,/** @export */gd:_emscripten_glPolygonOffset,/** @export */ec:_emscripten_glPolygonOffsetClampEXT,/** @export */dd:_emscripten_glQueryCounterEXT,/** @export */fd:_emscripten_glReadPixels,/** @export */ed:_emscripten_glReleaseShaderCompiler,/** @export */cd:_emscripten_glRenderbufferStorage,/** @export */bd:_emscripten_glSampleCoverage,/** @export */ad:_emscripten_glScissor,/** @export */$c:_emscripten_glShaderBinary,/** @export */_c:_emscripten_glShaderSource,/** @export */Zc:_emscripten_glStencilFunc,/** @export */Yc:_emscripten_glStencilFuncSeparate,/** @export */Xc:_emscripten_glStencilMask,/** @export */Wc:_emscripten_glStencilMaskSeparate,/** @export */Vc:_emscripten_glStencilOp,/** @export */Tc:_emscripten_glStencilOpSeparate,/** @export */Sc:_emscripten_glTexImage2D,/** @export */Rc:_emscripten_glTexParameterf,/** @export */Qc:_emscripten_glTexParameterfv,/** @export */Pc:_emscripten_glTexParameteri,/** @export */Oc:_emscripten_glTexParameteriv,/** @export */Nc:_emscripten_glTexSubImage2D,/** @export */Mc:_emscripten_glUniform1f,/** @export */Lc:_emscripten_glUniform1fv,/** @export */Kc:_emscripten_glUniform1i,/** @export */Ic:_emscripten_glUniform1iv,/** @export */Hc:_emscripten_glUniform2f,/** @export */Gc:_emscripten_glUniform2fv,/** @export */Fc:_emscripten_glUniform2i,/** @export */Ec:_emscripten_glUniform2iv,/** @export */Dc:_emscripten_glUniform3f,/** @export */Cc:_emscripten_glUniform3fv,/** @export */Bc:_emscripten_glUniform3i,/** @export */Ac:_emscripten_glUniform3iv,/** @export */zc:_emscripten_glUniform4f,/** @export */xc:_emscripten_glUniform4fv,/** @export */wc:_emscripten_glUniform4i,/** @export */vc:_emscripten_glUniform4iv,/** @export */uc:_emscripten_glUniformMatrix2fv,/** @export */tc:_emscripten_glUniformMatrix3fv,/** @export */sc:_emscripten_glUniformMatrix4fv,/** @export */rc:_emscripten_glUseProgram,/** @export */qc:_emscripten_glValidateProgram,/** @export */pc:_emscripten_glVertexAttrib1f,/** @export */oc:_emscripten_glVertexAttrib1fv,/** @export */mc:_emscripten_glVertexAttrib2f,/** @export */lc:_emscripten_glVertexAttrib2fv,/** @export */kc:_emscripten_glVertexAttrib3f,/** @export */jc:_emscripten_glVertexAttrib3fv,/** @export */ic:_emscripten_glVertexAttrib4f,/** @export */hc:_emscripten_glVertexAttrib4fv,/** @export */hb:_emscripten_glVertexAttribDivisorANGLE,/** @export */gc:_emscripten_glVertexAttribPointer,/** @export */fc:_emscripten_glViewport,/** @export */j:_emscripten_has_asyncify,/** @export */Bb:_emscripten_request_fullscreen_strategy,/** @export */I:_emscripten_request_pointerlock,/** @export */ob:_emscripten_resize_heap,/** @export */ac:_emscripten_sample_gamepad_data,/** @export */n:_emscripten_set_beforeunload_callback_on_thread,/** @export */z:_emscripten_set_blur_callback_on_thread,/** @export */c:_emscripten_set_canvas_element_size,/** @export */h:_emscripten_set_element_css_size,/** @export */A:_emscripten_set_focus_callback_on_thread,/** @export */q:_emscripten_set_fullscreenchange_callback_on_thread,/** @export */g:_emscripten_set_gamepadconnected_callback_on_thread,/** @export */f:_emscripten_set_gamepaddisconnected_callback_on_thread,/** @export */t:_emscripten_set_keydown_callback_on_thread,/** @export */r:_emscripten_set_keypress_callback_on_thread,/** @export */s:_emscripten_set_keyup_callback_on_thread,/** @export */Bd:_emscripten_set_main_loop,/** @export */Ad:_emscripten_set_main_loop_timing,/** @export */F:_emscripten_set_mousedown_callback_on_thread,/** @export */D:_emscripten_set_mouseenter_callback_on_thread,/** @export */C:_emscripten_set_mouseleave_callback_on_thread,/** @export */G:_emscripten_set_mousemove_callback_on_thread,/** @export */E:_emscripten_set_mouseup_callback_on_thread,/** @export */u:_emscripten_set_pointerlockchange_callback_on_thread,/** @export */p:_emscripten_set_resize_callback_on_thread,/** @export */v:_emscripten_set_touchcancel_callback_on_thread,/** @export */x:_emscripten_set_touchend_callback_on_thread,/** @export */w:_emscripten_set_touchmove_callback_on_thread,/** @export */y:_emscripten_set_touchstart_callback_on_thread,/** @export */o:_emscripten_set_visibilitychange_callback_on_thread,/** @export */B:_emscripten_set_wheel_callback_on_thread,/** @export */Cb:_emscripten_set_window_title,/** @export */i:_emscripten_sleep,/** @export */pb:_environ_get,/** @export */qb:_environ_sizes_get,/** @export */l:_fd_close,/** @export */tb:_fd_read,/** @export */ib:_fd_seek,/** @export */sb:_fd_write,/** @export */kb:_proc_exit};var wasmExports=createWasm();var ___wasm_call_ctors=()=>(___wasm_call_ctors=wasmExports["Dd"])();var _playTromino=Module["_playTromino"]=(a0,a1,a2,a3)=>(_playTromino=Module["_playTromino"]=wasmExports["Ed"])(a0,a1,a2,a3);var _free=a0=>(_free=wasmExports["Fd"])(a0);var _malloc=a0=>(_malloc=wasmExports["Gd"])(a0);var __emscripten_timeout=(a0,a1)=>(__emscripten_timeout=wasmExports["Id"])(a0,a1);var __emscripten_stack_restore=a0=>(__emscripten_stack_restore=wasmExports["Jd"])(a0);var __emscripten_stack_alloc=a0=>(__emscripten_stack_alloc=wasmExports["Kd"])(a0);var _emscripten_stack_get_current=()=>(_emscripten_stack_get_current=wasmExports["Ld"])();var dynCall_vi=Module["dynCall_vi"]=(a0,a1)=>(dynCall_vi=Module["dynCall_vi"]=wasmExports["Md"])(a0,a1);var dynCall_iii=Module["dynCall_iii"]=(a0,a1,a2)=>(dynCall_iii=Module["dynCall_iii"]=wasmExports["Nd"])(a0,a1,a2);var dynCall_v=Module["dynCall_v"]=a0=>(dynCall_v=Module["dynCall_v"]=wasmExports["Od"])(a0);var dynCall_viiii=Module["dynCall_viiii"]=(a0,a1,a2,a3,a4)=>(dynCall_viiii=Module["dynCall_viiii"]=wasmExports["Pd"])(a0,a1,a2,a3,a4);var dynCall_ii=Module["dynCall_ii"]=(a0,a1)=>(dynCall_ii=Module["dynCall_ii"]=wasmExports["Qd"])(a0,a1);var dynCall_iiii=Module["dynCall_iiii"]=(a0,a1,a2,a3)=>(dynCall_iiii=Module["dynCall_iiii"]=wasmExports["Rd"])(a0,a1,a2,a3);var dynCall_viii=Module["dynCall_viii"]=(a0,a1,a2,a3)=>(dynCall_viii=Module["dynCall_viii"]=wasmExports["Sd"])(a0,a1,a2,a3);var dynCall_vii=Module["dynCall_vii"]=(a0,a1,a2)=>(dynCall_vii=Module["dynCall_vii"]=wasmExports["Td"])(a0,a1,a2);var dynCall_iiiiii=Module["dynCall_iiiiii"]=(a0,a1,a2,a3,a4,a5)=>(dynCall_iiiiii=Module["dynCall_iiiiii"]=wasmExports["Ud"])(a0,a1,a2,a3,a4,a5);var dynCall_iiiiiiii=Module["dynCall_iiiiiiii"]=(a0,a1,a2,a3,a4,a5,a6,a7)=>(dynCall_iiiiiiii=Module["dynCall_iiiiiiii"]=wasmExports["Vd"])(a0,a1,a2,a3,a4,a5,a6,a7);var dynCall_iiiiiiiiii=Module["dynCall_iiiiiiiiii"]=(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9)=>(dynCall_iiiiiiiiii=Module["dynCall_iiiiiiiiii"]=wasmExports["Wd"])(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9);var dynCall_iiiii=Module["dynCall_iiiii"]=(a0,a1,a2,a3,a4)=>(dynCall_iiiii=Module["dynCall_iiiii"]=wasmExports["Xd"])(a0,a1,a2,a3,a4);var dynCall_iiiiiiiiiiiiiiff=Module["dynCall_iiiiiiiiiiiiiiff"]=(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15)=>(dynCall_iiiiiiiiiiiiiiff=Module["dynCall_iiiiiiiiiiiiiiff"]=wasmExports["Yd"])(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15);var dynCall_jiji=Module["dynCall_jiji"]=(a0,a1,a2,a3,a4)=>(dynCall_jiji=Module["dynCall_jiji"]=wasmExports["Zd"])(a0,a1,a2,a3,a4);var dynCall_ji=Module["dynCall_ji"]=(a0,a1)=>(dynCall_ji=Module["dynCall_ji"]=wasmExports["_d"])(a0,a1);var dynCall_viiiii=Module["dynCall_viiiii"]=(a0,a1,a2,a3,a4,a5)=>(dynCall_viiiii=Module["dynCall_viiiii"]=wasmExports["$d"])(a0,a1,a2,a3,a4,a5);var dynCall_vffff=Module["dynCall_vffff"]=(a0,a1,a2,a3,a4)=>(dynCall_vffff=Module["dynCall_vffff"]=wasmExports["ae"])(a0,a1,a2,a3,a4);var dynCall_vf=Module["dynCall_vf"]=(a0,a1)=>(dynCall_vf=Module["dynCall_vf"]=wasmExports["be"])(a0,a1);var dynCall_viiiiiiii=Module["dynCall_viiiiiiii"]=(a0,a1,a2,a3,a4,a5,a6,a7,a8)=>(dynCall_viiiiiiii=Module["dynCall_viiiiiiii"]=wasmExports["ce"])(a0,a1,a2,a3,a4,a5,a6,a7,a8);var dynCall_viiiiiiiii=Module["dynCall_viiiiiiiii"]=(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9)=>(dynCall_viiiiiiiii=Module["dynCall_viiiiiiiii"]=wasmExports["de"])(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9);var dynCall_i=Module["dynCall_i"]=a0=>(dynCall_i=Module["dynCall_i"]=wasmExports["ee"])(a0);var dynCall_vff=Module["dynCall_vff"]=(a0,a1,a2)=>(dynCall_vff=Module["dynCall_vff"]=wasmExports["fe"])(a0,a1,a2);var dynCall_viiiiiii=Module["dynCall_viiiiiii"]=(a0,a1,a2,a3,a4,a5,a6,a7)=>(dynCall_viiiiiii=Module["dynCall_viiiiiii"]=wasmExports["ge"])(a0,a1,a2,a3,a4,a5,a6,a7);var dynCall_vfi=Module["dynCall_vfi"]=(a0,a1,a2)=>(dynCall_vfi=Module["dynCall_vfi"]=wasmExports["he"])(a0,a1,a2);var dynCall_viif=Module["dynCall_viif"]=(a0,a1,a2,a3)=>(dynCall_viif=Module["dynCall_viif"]=wasmExports["ie"])(a0,a1,a2,a3);var dynCall_vif=Module["dynCall_vif"]=(a0,a1,a2)=>(dynCall_vif=Module["dynCall_vif"]=wasmExports["je"])(a0,a1,a2);var dynCall_viff=Module["dynCall_viff"]=(a0,a1,a2,a3)=>(dynCall_viff=Module["dynCall_viff"]=wasmExports["ke"])(a0,a1,a2,a3);var dynCall_vifff=Module["dynCall_vifff"]=(a0,a1,a2,a3,a4)=>(dynCall_vifff=Module["dynCall_vifff"]=wasmExports["le"])(a0,a1,a2,a3,a4);var dynCall_viffff=Module["dynCall_viffff"]=(a0,a1,a2,a3,a4,a5)=>(dynCall_viffff=Module["dynCall_viffff"]=wasmExports["me"])(a0,a1,a2,a3,a4,a5);var dynCall_viiiiii=Module["dynCall_viiiiii"]=(a0,a1,a2,a3,a4,a5,a6)=>(dynCall_viiiiii=Module["dynCall_viiiiii"]=wasmExports["ne"])(a0,a1,a2,a3,a4,a5,a6);var dynCall_vfff=Module["dynCall_vfff"]=(a0,a1,a2,a3)=>(dynCall_vfff=Module["dynCall_vfff"]=wasmExports["oe"])(a0,a1,a2,a3);var dynCall_iiiiiiiii=Module["dynCall_iiiiiiiii"]=(a0,a1,a2,a3,a4,a5,a6,a7,a8)=>(dynCall_iiiiiiiii=Module["dynCall_iiiiiiiii"]=wasmExports["pe"])(a0,a1,a2,a3,a4,a5,a6,a7,a8);var dynCall_viiiiiiiiiii=Module["dynCall_viiiiiiiiiii"]=(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11)=>(dynCall_viiiiiiiiiii=Module["dynCall_viiiiiiiiiii"]=wasmExports["qe"])(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11);var dynCall_iiiiiidiiff=Module["dynCall_iiiiiidiiff"]=(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)=>(dynCall_iiiiiidiiff=Module["dynCall_iiiiiidiiff"]=wasmExports["re"])(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10);var dynCall_iidiiii=Module["dynCall_iidiiii"]=(a0,a1,a2,a3,a4,a5,a6)=>(dynCall_iidiiii=Module["dynCall_iidiiii"]=wasmExports["se"])(a0,a1,a2,a3,a4,a5,a6);var _asyncify_start_unwind=a0=>(_asyncify_start_unwind=wasmExports["te"])(a0);var _asyncify_stop_unwind=()=>(_asyncify_stop_unwind=wasmExports["ue"])();var _asyncify_start_rewind=a0=>(_asyncify_start_rewind=wasmExports["ve"])(a0);var _asyncify_stop_rewind=()=>(_asyncify_stop_rewind=wasmExports["we"])();// include: postamble.js
// === Auto-generated postamble setup entry stuff ===
var calledRun;dependenciesFulfilled=function runCaller(){// If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)
if(!calledRun)run();if(!calledRun)dependenciesFulfilled=runCaller};// try this again later, after new deps are fulfilled
function run(){if(runDependencies>0){return}preRun();// a preRun added a dependency, run will be called later
if(runDependencies>0){return}function doRun(){// run may have just been called through dependencies being fulfilled just in this very frame,
// or while the async setStatus time below was happening
if(calledRun)return;calledRun=true;Module["calledRun"]=true;if(ABORT)return;initRuntime();readyPromiseResolve(Module);postRun()}{doRun()}}run();// end include: postamble.js
// include: postamble_modularize.js
// In MODULARIZE mode we wrap the generated code in a factory function
// and return either the Module itself, or a promise of the module.
// We assign to the `moduleRtn` global here and configure closure to see
// this as and extern so it won't get minified.
moduleRtn=readyPromise;


  return moduleRtn;
}
);
})();
if (typeof exports === 'object' && typeof module === 'object')
  module.exports = createTrmnMod;
else if (typeof define === 'function' && define['amd'])
  define([], () => createTrmnMod);
